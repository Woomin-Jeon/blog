---
title: "[Algorithm] 시간복잡도와 공간복잡도, 그리고 Big-O"
date: 2020-02-09
tag: ["Posts"]
---


알고리즘을 평가하는 두 가지 요소는 다음과 같이 정리할 수 있다.  
"어떤 알고리즘이 어떠한 상황에서 더 빠르고 또 느린가?"  
"어떤 알고리즘이 어떠한 상황에서 메모리를 적게 쓰고 또 많이 쓰는가?"  
이렇듯 하나는 "속도"에 관한 것이고, 하나는 "메모리 사용량"에 관한 것인데, 속도에 해당하는 알고리즘의 수행시간 분석결과를 가리켜 "시간복잡도(time complexity)라고 하고, 메모리 사용량에 대한 분석결과를 가리켜 "공간복잡도(space complexity)라고 한다.  
  
## 시간복잡도

- 먼저, 알고리즘의 시간복잡도를 계산하는 방법은 처리해야할 데이터의 수 n에 대한 연산횟수의 함수 T(n)을 만들면 된다. 예를들어,

  ```javascript
  for (let i = 0; i < n; i++) {
    if (value[i] === target) {
      return i;
    }
  }
  ```

  위와 같은 코드가 있을 때, n = 10일 때 최대 연산횟수는 10이고, n = 100일 때 최대 연산횟수는 100이다. 이 경우 T(n) = n 이라고 볼 수 있다. 그렇다면 아래와 같은 코드는 어떨까?

  ```javascript
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (value[i] === target[j]) {
        return i;
      }
    }
  }
  ```

  n = 10일 때 최대 연산횟수는 100이고, n = 100일때 최대 연산횟수는 10,000이다. 즉, 이 경우 T(n) = n²이다.  
  
  하지만 이렇게 시간 복잡도를 "T(n) = 3n² + 2n + 6" 과 같이 표시하기에는 한번에 알아보기도 힘들고 불편한 점이 많다. 그렇기 때문에 사용되는 것이 "Big-O" 표기법이다. Big-O 표기법은 최고차항의 차수만을 고려하는 것이다. 예를 들어 방금과 같이 "T(n) = 3n² + 2n + 6" 의 경우에 Big-O는 O(n²)이 된다.  
  
  대표적인 Big-O에는  
  O(1)  
  O(log n)  
  O(n)  
  O(nlog n)  
  O(n²)  
  O(n³)  
  O(2^n)  
  O(c^n)  
  등이 있으며, 위의 순서대로 시간복잡도가 증가한다.  
  ![이미지](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F22158A4F565E7A6219ACF4)  
  
## 공간복잡도

- 공간 복잡도 계산 메모리를 얼마나 사용하는지를 확인하면 된다.

  예를 들어, 크기가 n인 배열을 입력했는데 알고리즘이 내부에서 n x n의 이차원 배열을 생성한다면 이 알고리즘의 공간 복잡도는 n²이 된다.
