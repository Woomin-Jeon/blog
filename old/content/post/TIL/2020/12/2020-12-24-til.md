---
title: 2020-12-24 TIL
date: 2020-12-24
tag: [TIL]
---

## Facts

- 오전에는 프로그래머스 "가장 큰 수"를 풀어보려고 했으나 실패했습니다.
- 부캠 스터디에서 어제 공부했던 내용을 면접식으로 주고받았습니다.
- JavaScript 객체에 대해 공부했습니다.
- 이진 탐색 트리, 해시 테이블 등의 자료구조를 공부했습니다.
- 밀린 "오늘의 문제"들을 풀어봤습니다... 107문제가 밀려있네요.
- Redux 공식문서의 "Understanding Redux" 파트의 내용들을 쭉 읽어보았습니다. 영문서긴 했는데 생각보다 재미있어서 주욱 읽은 것 같아요.
- 자료구조 스터디에 참여하였습니다.

## Feelings

- 왜 이렇게 쉬고싶은지 모르겠습니다. 으어어
- 오늘도 다시금 느낍니다. 모든 것은 공식문서에 있다. (하지만 맨날 공식문서는 손이 잘 안가죠...)

## Findings

- **Symbol 타입**  
  유일무이한 식별자를 만들고자 할 때 사용됩니다.

- **이진 탐색 트리**  
  이진 탐색과, LinkedList의 장점을 얻을 수 있어서, 이진 탐색의 효율적인 탐색 능력을 가지고 있고(O(logN)), LinkedList 처럼 삽입과 삭제속도도 빠르기 때문에 사용됩니다.
  - 삽입  
    - 탐색을 실패한 위치에 됩니다.
  - 삭제  
    - 삭제하려는 노드가 단말노드일 경우(자식 노드가 없을 경우), 해당 노드의 연결을 끊어줍니다.
    - 삭제하려는 노드가 하나의 서브트리만 가지는 경우(왼쪽 혹은 오른쪽 둘 중 하나만), 자식 노드와 할아버지 노드를 이어주면 됩니다.
    - 삭제하려는 노드가 두 개의 서브트리를 모두 가지고 있는 경우, 왼쪽 서브 트리 중 가장 큰 값, 혹은 오른쪽 서브트리 중 가장 작은 값을 삭제하려는 노드 자리에 바꿔 넣어 줍니다.

- **해시 테이블**  
  해시 테이블이란 key와 value를 매핑하는 데이터 구조입니다. 해시 함수로 얻은 key를 index로 사용하고 해당 index에 데이터를 저장하여 효율적인 검색을 할 수 있습니다. 시간 복잡도는 O(1)입니다.  
  충돌은 다음과 같이 해결할 수 있습니다.  
  - Separate Chaining
  key에 대한 index가 가리키는 자료구조를 LinkedList로 이용하는 방식입니다.
  - Open Addressing
  해시 충돌이 발생하면 해시 함수로 얻은 주소가 아닌 다른 주소 공간에 데이터를 저장하는 방식입니다. 여기에는 선형 탐사(다음 비어있는 공간을 탐색), 제곱 탐사(제곱만큼 이동해서 빈 공간을 탐색), 이중 해싱(다른 해시함수를 한번 더 적용)이 있습니다.

- **가비지 컬렉션**
  - JavaScript에서 가비지 컬렉션은 "도달 가능성"을 통해 가비지로 수집할지 말지 결정합니다. 먼저 루트(root)정보를 수집하고 이를 mark(기억)합니다. 그리고 루트가 참조하는 모든 객체를 방문해서 이를 mark하게 되며 도달 가능한 모든 객체를 방문할때까지 mark를 반복합니다. 그리고 mark되지 않은 모든 객체를 메모리에서 삭제합니다.
  - 가비지 컬렉션의 최적화 기법
    - generational collection (세대별 수집)  
    일정 시간 이상 동안 살아남은 객체는 "오래된 객체"로 분류하고 가비지 컬렉터가 덜 감시합니다.
    - incremental collection (점진적 수집)  
    가비지 컬렉션을 여러 부분으로 분리하고 각 부분을 별도로 수행합니다. 즉, 가비지 컬렉션으로 인한 긴 지연을 짧은 지연 여러개로 분산시킵니다.
    - idle-time collection (유휴 시간 수집)  
    CPU가 유휴 상태일 때만 가비지 컬렉션을 실행합니다.

- **Optional Chaining의 활용**  
  - 객체의 메서드가 존재하는 경우에만 호출

      ```js
      const user1 = {
        name: 'woo',
        getName() {
          return this.name;
        },
      };

      const user2 {
        name: 'min',
      }

      user1.getName?.(); // woo
      user2.getName?.(); //
      ```
  - user가 존재하면 user.name을 삭제한다.

      ```js
      delete user?.name;
      ```

## Future Action Plans

- 앞으로 새로운 기술을 익힐 때는 반드시 무조건 꼭 공식문서부터 시작해야겠습니다. 그리고 그걸 어떻게 사용하는지보다는 이게 왜 나왔는지와 같은 히스토리나 철학과 같은 것들을 놓치지 말아야겠습니다. 진짜 이건 앞으로 무조건 지켜야겠어요.

## Feedback

- OK
