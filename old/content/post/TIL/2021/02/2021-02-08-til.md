---
title: 2021-02-08 TIL
date: 2021-02-08
tag: [TIL]
---

## Facts

- iter1: 네이버 D2에 있는 "최신 브라우저 내부동작2"와 "어서와 SSR은 처음이지?" 라는 글들을 읽어보았습니다.
- iter2: 프로그래머스 3레벨 "길 찾기 게임" 문제를 풀어보려고 했는데 실패했습니다.
- iter3: "길 찾기 게임" 문제를 계속 해결해보려 했고, 거의 실마리를 잡은 것 같은 느낌입니다.
- iter4: "길 찾기 게임" 문제 결국 해결하는 데 성공했습니다. 아울러 전위순회와 후위순회 방식에 대해서 공부하였습니다.
- 이태원 코딩도장 "거침없는 자바스크립트 1회차" 스터디에 참여하였습니다.

## Feelings

- 오늘 카카오 에드핏 광고 허용이 떨어져서 배포를 하였는데, "상식 테스트"가 오늘 하루 약 1000건 정도의 조회수를 올린 것 같아 뿌듯했습니다. 사람들이 많이 사용해주니까 좋네요.

## Findings

- JavaScript의 기존 함수는 클래스 기능도 가지고 있어서 무거웠던 반면, 화살표 함수는 함수의 기능만 가지고 있어서 더 가벼운 함수 객체입니다.
- 메인 쓰레드는 최대한 빨리 끝내주는 게 좋습니다. 이렇게 메인 쓰레드를 빨리 끝내주기 위해서는 다른 쓰레드에게 일부 일을 맡기는 방식을 사용할 수 있습니다. 원래 폰 노이만 머신은 Blocking이 강제되지만, 이는 어쩔 수 없는 부분이기 때문에 Blocking을 최소화하는 방향으로 가게 되는데 이를 Non-Blocking이라고 합니다. 즉, 이런 Non-Blocking을 위해서 앞서 말했듯, 메인 쓰레드의 일을 다른 쓰레드에게 맡김으로써 Blocking을 줄입니다. 예를 들어 원래 메인 쓰레드가 10초 동안 작업을 Blocking으로 하게된다고 할 때, 5초의 작업은 다른 쓰레드에게 맡김으로써 메인 쓰레드의 Blocking 시간을 5초로 줄일 수 있는데, JavaScript에 이를 적용하면 메인쓰레드가 JavaScript 싱글쓰레드, 다른 쓰레드가 웹 워커 쓰레드라고 볼 수 있습니다. 아울러 다른 쓰레드의 작업이 완료된 후의 결과물을 메인쓰레드가 받아서 다시 처리하기까지 메인쓰레드는 대기하고 있다가 결과가 오면 처리를 하기 시작하는데 이것이 바로 JavaScript의 이벤트루프라고 볼 수 있습니다.

- **전위순회와 후위순회**  

    ```js
    // 전위순회
    const preorder = (node) => {
      if (!node) {
        return [];
      }
      
      return [
        node.number,
        ...preorder(node.leftChild),
        ...preorder(node.rightChild),
      ];
    }

    // 후위순회
    const postorder = (node) => {
      if (!node) {
        return [];
      }
      
      return [
        ...postorder(node.leftChild),
        ...postorder(node.rightChild),
        node.number,
      ];
    }
    ```

## Future Action Plans

- 오늘 사실상 한 게... 알고리즘 문제 푼 거 밖에 없어보이네요... 내일은 이터레이션 돌면서 더 빡세게 공부해야겠습니다.
- 알고리즘 문제 풀이 계획 추상적이지 않고 구체적으로 짜는 연습을 해야겠습니다. 정말 딱 계획에 써있는 글씨를 나는 구현만 하면 해결할 수 있도록.

## Feedback

- OK
