---
title: 그림으로 배우는 HTTP 스터디 2
date: 2020-02-18
tag: [Study]
---

## "그림으로 배우는 HTTP" 스터디 2

### 4장: 결과를 전달하는 HTTP 상태코드

#### 상태코드 역할
  
- 상태코드의 역할은 클라이언트가 서버를 향해 리퀘스트를 보낼 때 서버에서 그 결과가 어떻게 되었는지 알려주는 것이다.

#### 상태코드

- 1XX : Informational : 리퀘스트를 받아들여 처리중  
  2XX : Succescc : 리퀘스트를 정상적으로 처리했음  
  3XX : Redirection : 리퀘스트를 완료하기 위해 추가 동작이 필요  
  4XX : Client Error : 리퀘스트 이해 불가능  
  5XX : Server Error : 리퀘스트 처리 실패  

### 5장: HTTP와 연계하는 웹서버

#### 프록시
  
- 프록시에는 캐싱프록시와 투명프록시가 존재한다. 캐싱프록시는 프록시로 리스폰스를 중계할 때 프록시 서버 상에 리소스 캐시를 보존하는 타입의 프록시를 말하며, 투명프록시는 프록시로 리퀘스트와 리스폰스를 중계할 때 메시지 변경을 하지 않는 타입의 프록시를 말한다. 프록시를 경유할 때는 Via 헤더 필드에 경유한 호스트 정보를 추가해야 한다.

#### 게이트웨이

- 게이트웨이의 동작은 프록시와 몹시 유사한데, HTTP 서버를 제공하는 것이 프록시라면 HTTP 서버 이외의 서비스를 제공하는 서버가 바로 게이트웨이이다. 게이트 웨이는 클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안정성을 높여서 쇼핑사이트 등의 결재 시스템 등과 연계할 때 사용되기도 한다.

#### 터널

- 터널이란, 다른 서버와 통신을 할 때 SSL과 같은 암호화 통신을 통해 서버와 안전하게 통신하기 위해 사용되는 것이다.

#### 캐시

- 캐시는 프록시 서버와 클라이언트의 로컬디스크에 보관된 리소스 사본을 가리키는데, 이 캐시를 사용하면 리소스를 가진 서버의 엑세스를 줄이는 것이 가능하기 때문에 통신량과 통신 시간을 줄일 수 있다는 장점이 있다. 또한, 오리진 서버의 리소스가 갱신되는 경우에도 같은 캐시를 계속 쓰게되면 서버는 갱신되기 전의 낡은 리소스를 그대로 보내기 때문에 캐시에는 유효기간이 존재한다.

### 6장: HTTP 헤더

#### 헤더필드

- HTTP 헤더필드에는 총 4종류가 있는데 다음과 같다.
  
  1. 일반적 헤더 필드 : 리퀘스트 메세지와 리스폰스 메세지 둘 다 사용되는 헤더이다.
  2. 리퀘스트 헤더 필드 : 클라이언트에서 서버로 송신한 리퀘스트 메세지에 사용되는 헤더로, 리퀘스트의 부가적인 정보와 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선순위 등이 적혀있다.
  3. 리스폰스 헤더 필드 : 서버에서 클라이언트로 송신하는 리스폰스 메세지에 사용되는 헤더로, 리스폰스의 정보와 서버 정보, 클라이언트의 추가 정보 요구 등이 적혀 있다.
  4. 엔티티 헤더 필드 : 리퀘스트 메세지와 리스폰스 메세지에 포함된 엔티티에 사용되는 헤더로, 콘텐츠 갱신 시간 등의 엔티티에 관한 정보가 적혀 있다.

#### End to end & Hop by hop

- HTTP 헤더 필드는 캐시와 비캐시 프록시의 동작을 정의하기 위해 End to end와 Hop by hop 헤더로 분류된다.  
  End to end 헤더는 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존돼야 하며, 다시 전송되지 않으면 안되도록 되어 있다.  
  Hop by hop 헤더는 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 존재한다.

#### Cache-Control 헤더

- Cache-Control 헤더는 디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정한다. 그 중 no-cache 디렉티브라는 것이 존재하는데, 이는 캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용된다.  
  클라이언트 리퀘스트로 no-cache가 사용된 경우에는 캐시된 리스폰스를 클라이언트가 받아들이지 않을 것이라는 걸 나타낸다. 즉, 이렇게 되면 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송해야한다.  
  서버 리퀘스트로 no-cache가 사용된 경우, 캐시 서버는 리소스를 저장할 수가 없다. 이 경우 캐시서버는 리소스를 사용할 때, 오리진 서버에 가서 유효성 확인을 받아야 한다.

#### Connection 헤더 필드

- Connection 헤더 필드는 프록시 서버에 더 이상 전송하지 않는 헤더 필드(hop-by-hop 헤더)를 지정할 수 있도록 한다. 또한, HTTP/1.1에서는 지속적 접속이 디폴트로 되어있는데 이를 서버에서 명시적으로 끊고 싶을 때, Connection 헤더 필드에 `Connection : Close` 를 입력 함으로써 수행할 수 있다.

#### Upgrade 헤더 필드

- Upgrade 헤더 필드는 HTTP 및 다른 프로토콜의 새로운 버전을 통신에 이용하고자 할 때 사용된다. 이 경우 앞서 언급하였던 Connection 헤더 필드를 추가적으로 지정해야 한다. Connection : Upgrade

#### Via 헤더 필드

- Via 헤더 필드는 클라이언트와 서버 간의 리퀘스트나 리스폰스 메세지의 경로를 알기 위해서 사용된다. Via 헤더 필드는 전송된 메시지의 추적과 리퀘스트 루프를 막는 데에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 추가해주어야 한다.

#### Accept 헤더 필드

- Accpet 헤더 필드는 유저 에이전트에서 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선순위를 전달하기 위해 사용된다.  
  가령, `Accept-Language: ko-kr, en-us;q=0.7, en; q=0.3` 은 ko-kr 언어를 en-us 언어보다 우선적으로 적용하라는 것을 나타낸다.

#### Host 헤더 필드

- Host 헤더 필드는 리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달하는 역할을 한다. 만약 리퀘스트가 서버에서 오는 경우 호스트 명을 IP 주소로 해결해서 리퀘스트가 처리되는데, 이 때 만약 같은 IP 주소로 복수의 도메인이 적용되어 있다면 어느 도메인에 대한 리퀘스트인지 알 수가 없게된다. 이런 경우를 대비하기 위해서 Host 헤더 필드에 리퀘스트를 받을 호스트 명을 기입하는 것이다. 이와 같은 역할로 인해서 Host 헤더 필드는 HTTP/1.1에서 유일한 필수 헤더 필드이다.

#### If-XXXX 헤더 필드

- If-Match : ETag가 일치하는 경우에만 리퀘스트를 받아 들인다.  
  If-None-Match : ETag가 일치하지 않는 경우에만 리퀘스트를 받아 들인다.  
  If-Modified-Since : 리소스의 갱신 날짜가 필드 값보다 새롭지 않다면 리퀘스트를 받아들인다.  
  If-Unmodified-Since : 리소스의 갱신 날짜가 필드 값보다 새롭다면 리퀘스트를 받아들인다.  
  If-Range : ETag 값 혹은 갱신 날짜가 일치하면 리퀘스트를 받아들인다.  

#### ETag 헤더 필드

- ETag 헤더 필드는 엔티티 태그라고 불리며, 리소스를 특정하기 위한 문자열 전달을 목적으로 한다. 만약 다운로드 도중에 다운로드가 귾기는 경우 ETag값을 참조해서 리소스를 특정하고 거기서부터 다운로드를 재개할 수 있다. 

#### Location 헤더 필드

- Location 헤더 필드는 리스폰스의 수신자에 대해서 Request-URI 이외의 리소스 엑세스를 유도하는 경우에 사용된다. 기본적으로 상태코드 `3XX : Redirection` 리스폰스에 대해서 리다이렉트 처의 URI를 기술하여 그쪽으로 엑세스를 유도한다.

#### Vary 헤더 필드

- Vary 헤더 필드는 캐시를 컨트롤하기 위해서 사용된다. 프록시 서버가 클라이언트로부터 Vary로 지정된 리소스를 리퀘스트 받게 되면, 같은 Vary 헤더 필드가 있는 경우에는 캐시에서 리스폰스를 하고, 다른 경우에는 오리진 서버로 가서 리소스를 가져온 후 리스폰스 한다.

#### Content-MD5 헤더 필드

- Content-MD5 헤더 필드는 메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5 알고리즘에 의해서 생성된 값을 전달한다. 즉, 콘텐츠를 받았을 때, MD5로 생성된 값과 비교해봄으로써 콘텐츠가 원본 그대로 제대로 왔는지 확인할 수 있다. 하지만 악의적으로 콘텐츠 변조를 하려는 나쁜 사람이 있다면 그는 콘텐츠뿐만아니라 MD5 값 역시도 변경할 수 있기 때문에 이를 막을 수는 없다는 한계가 있다.

#### Cookie의 속성

- **Expires 속성** : 쿠키의 Expires 속성은 부라우저가 쿠키를 송출할 수 있는 유효기간을 지정하는 데 사용된다. 만약 이 속성을 지정하지 않는 경우에는 브라우저 세션이 유지되고 있는 동안만 쿠키가 유효해진다. 그리고 쿠키는 서버에서 명시적으로 삭제하는 방법이 없기 때문에, 유효기간이 지난 쿠키에 대해서는 쿠키를 덮어쓰는 방식으로 실질적인 클라이언트 측의 쿠키를 삭제할 수 있다.  
- **Domain 속성** : 쿠키의 Domain 속성은 여러 도메인에 대해 쿠키를 송출하는 경우 사용된다. 예를 들어, `example.com`으로 Domain 속성을 지정하게 되면, `www.example.com`으로도 쿠키가 송출되고 `www2.example.com`으로도 쿠키가 송출되게 된다.  
- **Secure 속성** : 쿠키의 Secure 속성은 웹 페이지가 HTTPS에서 열렸을 때에만 쿠키 송출을 하기 위해서 사용된다. 만약 이 속성을 생략하게 되면 HTTP에서도 쿠키 송출이 가능해진다.  
- **HttpOnly 속성** : 쿠키의 HttpOnly 속성은 JavaScript를 경유해서 쿠키를 취득하는 것(`[document.cookie]`)이 불가능하도록 하는 쿠키 확장 기능이다. 크로스 사이트 스트립팅(XSS)으로부터 쿠키의 도청을 막는 것을 목적으로 한다.
