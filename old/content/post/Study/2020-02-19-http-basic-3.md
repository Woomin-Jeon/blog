---
title: 그림으로 배우는 HTTP 스터디 3
date: 2020-02-19
tag: [Study]
---

## "그림으로 배우는 HTTP" 스터디 3

### 7장: HTTPS

#### 통신 암호화와 콘텐츠 암호화

- 통신 암호화란 SSL을 이용하여 HTTP 통신 내용을 암호하는 것이다. SSL을 사용하여 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 한다.

#### 위장 가능성  
  
- 위장 가능성을 방지하기 위해서는 증명서를 이용한다. 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행되는 것을 말한다.

#### 변조 가능성  
  
- 변조 가능성을 방지하기 위해서는 MD5나 PGP, SHA-1, 디지털 서명 등을 사용한다. 하지만 변조하고자 하는 사람이 마음먹고 한다면, MD5나 PGP와 같은 것들 자체도 적절하게 수정할 수 있기 때문에 한계가 존재한다.

#### HTTPS 프로토콜의 계층 구조  

- HTTP => HTTP - TCP - IP  
  HTTPS => HTTP - SSL - TCP - IP

#### 공통키 암호화  
  
- 공통키 암호화란 암호화와 복호화에 하나의 키를 같이 사용하는 방식을 말한다. 하지만 이런 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안되는데 이 네트워크 과정에서 탈취를 당할 위험이 존재한다. 이 때문에 공통키가 무력해질 수 있다는 딜레마가 있다.

#### 공개키 암호화  
  
- 공개키 암호화란 공개키와 비밀키 두 가지의 키를 사용하는 방식이다. 공개키는 클라이언트가 서버에게 데이터를 보낸다고 가정할 때, 서버의 공개키를 받아오고 이를 사용하여 데이터를 암호화 한 뒤 이를 서버에게 전송한다. 그러면 서버는 이를 받아서 자신이 갖고 있던 비밀키를 이용해 복호화하여 안의 데이터를 확인하는 방식이다. 이 방식은 공개키 만으로 복호화를 할 수 없기 때문에 공개키가 탈취되어도 문제가 발생하지 않아서 위의 공통키 암호화 방식의 딜레마를 해결할 수 있다.

#### HTTPS 하이브리드 암호 시스템  
  
- 하지만 위의 공개키도 단점이 존재하는데 이는 속도가 느리다는 것이다. 그렇기 때문에 이를 극복하고자 HTTPS에서는 공통키를 공개키 암호화를 사용하여 안전하게 교환하는 하이브리드 암호 시스템을 사용한다.

#### 공개키 증명서  
  
- 공개키 암호에도 문제점이 존재하는데 이는 받아오는 공개키가 진짜인지 아닌지를 증명할 수 없다는 것이다. 이러한 문제점때문에 인증기관으로부터 공개키 증명서를 받아와서 자신이 진짜임을 인증하는 방식이 사용되고 있다.

#### 공개키와 비밀키, 그리고 인증기관을 모두 거친 메시지 송수신 과정  
  
- 클라이언트가 데이터를 서버로 보내는 입장이라고 가정할 때, 먼저 서버는 인증기관에게 자신의 공개키를 등록하고 인증기관을 통해 디지털 서명을 받는다. 그리고 클라이언트는 서버의 공개키 증명서를 보고 "음 진짜로군" 한 다음 위의 공개키 암호화 과정에서 설명하였던 일련의 과정을 수행한다.

#### 클라이언트 증명서  
  
- 클라이언트 증명서란 서버와 통신하고 있는 클라이언트가 서버가 의도한 상대라는 것을 증명해주는 인증서를 말한다. 하지만 이 클라이언트 증명서에는 문제점이 있는데, 첫번째로 클라이언트 증명서는 유료이기 때문에 비용이 든다는 문제점이 있으며, 두번째로 클라이언트의 실재를 증명할 뿐 사용자의 존재 유무를 증명하지는 않는다는 것이다. 이 말은 쉽게 말해 어머니의 공인인증서를 사용하여 아들이 결제를 하여도 서버는 알 수 없다는 뜻이다.

#### HTTPS 통신 과정  

  1. 클라이언트가 Client Hello 메시지를 송신하면서 SSL 통신을 시작한다.
  2. 서버 역시 SSL 통신이 가능한 경우에는 server Hello 메시지로 응답한다.
  3. 서버가 공개키 증명서가 포함된 Certificate 메시지를 송신한다.
  4. 서버가 Hello Done 메시지를 송신하여 SSL 네고시에이션 부분이 끝났음을 알린다.
  5. SSL 최초 네고시에이션이 종료되면 클라이언트가 Client Key Exchange로 응답한다.
  6. 클라이언트는 Change Cipher Spec 메시지를 송신한다. 이 후 통신은 암호키를 사용하여 진행된다.
  7. 클라이언트는 Finished 메시지를 송신한다.
  8. 서버 역시 Change Cipher Spec 메시지를 송신한다.
  9. 서버 역시 Finished 메시지를 송신한다.
  10. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의한 접속이 확립된다.
  11. 어플리케이션 계층의 프로토콜에 의한 통신을 시작한다.
  12. 마지막에 클라이언트가 close_notify 메시지를 송신하면서 접속을 끊는다.

#### SSL 통신이 지연되는 이유  
  
- TCP 접속과 HTTP 리퀘스트/리스폰스 이외에 SSL이 추가적으로 들어가기 떄문에 전체적으로 처리해야하는 네트워크 통신이 증가하게 된다. 또한, SSL로 암호화 처리를 하고 있기 떄문에 서버나 클라이언트에서 암호화나 복호화를 위한 계산을 처리하게 되며 이는 리소스를 소비하게 되어 부담이 커지게 된다.
