---
title: 운영체제와 정보기술의 원리 정리
date: 2021-01-09
tag: [Study]
---

`참고` 이 글은 반효경 교수님의 "운영체제와 정보기술의 원리"를 바탕으로 공부한 내용을 정리한 것입니다.

<br><br>

## 2장 운영체제 개요

### 1. 운영체제의 정의

- 사용자 입장에서 하드웨어 자체를 다룬다는 것은 쉽지 않기 때문에, 하드웨어 위에 운영체제를 탑재해 사용하게 됩니다.

### 2. 운영체제의 기능

- 운영체제의 주요 기능은 컴퓨터 시스템 내의 자원을 효율적으로 관리하는 것과, 사용자가 컴퓨터 시스템을 편하게 사용할 수 있는 환경을 제공하는 것입니다.
- 또한 운영체제는 자원관리 뿐만아니라 보안 및 보호 기능도 수행합니다.

### 3. 운영체제의 분류

- 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 `다중 프로그래밍 시스템`이라고 합니다.
- 사용자의 요청에 대한 결과를 곧바로 얻을 수 있는 시스템을 `대화형 시스템`이라고 합니다. 예를들면, 다중 작업용 운영체제에서 여러 프로그램을 같이 실행시키지만 사용자 입장에서는 각 프로그램의 키보드 입력 결과를 곧바로 화면에 볼 수 있는 것이 있습니다. (우리가 흔히 아는 서버도 대화형 시스템이라고 볼 수 있습니다)

### 4. 운영체제의 예

- MS 윈도우는 유닉스 같이 오랜 전통을 가지는 운영체제에 비해 안정성이 떨어지지만, 사용이 편리한 여러가지 기능들을 제공하기 때문에 일반적인 사용자들에게 가장 보편적으로 사용됩니다.
- 유닉스는 C언어로 작성되어 이식성이 크고, 커널의 크기가 작으며, 여러가지 유틸리티들을 지원해서 프로그래밍 환경에 이상적인 운영체제입니다. 아울러 안정성이 크고 사용자가 자신에게 적합한 환경을 스스로 꾸밀 수 있는 운영체제로, 전문가에게 적합합니다.

### 5. 운영체제의 자원 관리 기능

- 운영체제는 CPU 스케줄링을 통해 CPU를 효율적으로 사용하고 특정 프로세스가 불이익을 당하지 않도록 관리합니다.
- 운영체제는 고정분할, 가변분할, 가상메모리 방식과 같은 것들을 사용하여 메모리 공간히 효율적으로 사용되도록 관리하고, 서로 다른 프로세스끼리 메모리 영역을 침범하지 않도록 보안을 유지하는 역할을 합니다.
- 또한, 운영체제는 주변장치 및 입출력 장치를 인터럽트 메커니즘을 통해 관리합니다.

<br>
---
<br>

## 3장 컴퓨터 시스템의 동작 원리

### 1. 컴퓨터 시스템의 구조

- 컴퓨터 시스템은 컴퓨터 내부장치(CPU, 메모리)와 외부장치(디스크, 키보드, 마우스, 모니터, 네트워크 장치 등)로 구성됩니다.  
- 운영체제는 각종 자원 관리를 위해 항상 메모리에 올라가있어야 하는데 모든 코드가 메모리에 올라가게되면 메모리가 낭비되므로 핵심적인 부분만 메모리에 올리게됩니다. 이를 `커널`이라고 부릅니다.

### 2. CPU 연산과 I/O 연산

- 각 입출력 장치들의 I/O 연산은 `입출력 컨트롤러`가 담당하고, 컴퓨터 내에 수행되는 연산은 메인 CPU가 담당합니다.
- 그리고 각 입출력 장치들의 컨트롤러는 장치로부터 오고나가는 데이터를 임시로 저장하기위해 `로컬 버퍼`라는 작은 메모리를 가지게 됩니다.
- 장치로부터 로컬 버퍼로 데이터를 읽어오는 역할은 컨트롤러가 담당하는데, 이 역할이 끝나게되면 인터럽트를 통해 CPU에게 작업 완료를 알리게됩니다.

### 3. 인터럽트의 일반적 기능

- 운영체제 커널 안에는 각 인터럽트에 대한 처리 루틴이 미리 프로그래밍 되어 있어서 인터럽트가 발생하면 이를 사용합니다.
- 인터럽트에는 `하드웨어 인터럽트`와 `소프트웨어 인터럽트`가 있습니다. 하드웨어 인터럽트는 통상적으로 우리가 일컷는 인터럽트를 말하며, 소프트웨어 인터럽트는 예외상황(Exception)이나 시스템 콜(System call)로 인해 발생하는 인터럽트를 의미합니다. 여기서 예외상황은 0으로 나누는 것, 자신의 메모리 바깥 영역에 침범하는 등의 예외적인 상황을 말합니다.

### 4. 인터럽트 핸들링

- 인터럽트가 발생하면 실행중이던 프로그램의 상태를 PCB에 저장한 뒤, 인터럽트 처리 루틴에 따라 인터럽트를 처리하게 됩니다. 그리고 인터럽트 처리가 끝나게되면 저장해두었던 상태를 프로그램의 PCB로부터 복원해서 인터럽트 당하기 직전의 위치부터 실행을 재개합니다.

### 5. 입출력 구조

- 입출력 방식에는 동기식 입출력과 비동기식 입출력이 존재합니다.
- `동기식 입출력`은 어떤 프로그램이 입출력 요청을 했을 때, 입출력 작업이 완료된 뒤에야 후속 작업을 수행할 수 있는 것을 말합니다. 이때문에 동기식 입출력에서는 CPU가 입출력이 끝날때까지 기다리기 때문에 CPU 자원을 낭비하게 됩니다. 따라서 일반적으로는 프로그램이 입출력을 수행하는 경우 CPU를 다른 프로그램에게 넘겨서 CPU를 계속 사용하도록 하고, 입출력 과정이 완료될 때까지 해당 프로그램을 Block 상태로 만들어서 CPU를 할당하지 않습니다.  
  (참고로, 입출력 과정이 완료되면 위에서 설명했듯이 입출력 컨트롤러가 CPU에게 인터럽트를 보내게되며 Block 상태가 해제됩니다.)
- 이런 동기식 입출력은 입출력에 걸린 프로그램으로부터 CPU를 빼앗아 다른 프로그램에게 넘기기 때문에 연산 과정의 순서가 꼬일 위험이 있습니다. 이러한 문제점, 즉 동기화 문제를 해결하기 위해 장치별로 큐(Queue)를 두고 요청한 순서대로 처리합니다.
- `비동기식 입출력`은 어떤 프로그램이 입출력 요청을 했을 때, 다시 그 프로그램에게 CPU를 부여합니다. 이렇게 함으로써 입출력 결과로 나올 데이터를 사용하지 않는 작업을 먼저 수행합니다.
- 일반적으로는 동기식 입출력을 사용한다고 합니다.

### 6. DMA(Direct Memory Access)

- 원칙적으로 메모리는 CPU만이 접근할 수 있는 장치입니다. 따라서 CPU가 아닌 장치가 메모리에 접근하기 위해서는 CPU에게 부탁하는 방식으로만 가능합니다.
- 하지만 이렇게 하다보니 입출력 장치가 메모리 접근을 원할때마다 CPU에게 부탁을 하게되고 CPU는 자기 할 일을 못하게됩니다.
- 이러한 문제를 해결하기 위해 CPU 이외에 메모리에 접근할 수 있는 장치를 하나 더 두었는데 이것이 바로 `DMA`입니다. DMA는 일종의 컨트롤러로, 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 CPU 대신 수행해서 CPU가 이로인해 방해받지 않도록 합니다. DMA는 이렇게 로컬버퍼의 데이터를 메모리로 읽어온 뒤 CPU에게 완료되었다는 인터럽트를 발생시키게됩니다.

### 7. 저장장치의 구조

- 컴퓨터 시스템을 구성하는 저장장치는 주기억장치와 보조기억장치로 나뉩니다.
- 보조기억 장치의 용도는 파일을 저장하기 위한 파일 시스템용과 메모리의 연장공간인 스왑 영역이 있습니다.
- 현대의 컴퓨터는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분을 `스왑 영역`에 내려놓게 됩니다.

### 8. 저장장치의 계층 구조

- 레지스터 - 캐시메모리 - 메인메모리 - 마그네틱디스크 - 광디스크 - 마그네틱테이프

### 9. 하드웨어 보안

- 운영체제는 하드웨어적인 보안을 유지하기 위해서 커널모드와 사용자모드를 나눕니다. CPU 내부에 모드비트(mode bit)라는 걸 두고 0일 때는 커널모드, 1일때는 사용자모드로서 명령을 수행할 수 있게합니다.

### 10. 메모리 보안

- C언어 포인터 등 메모리 주소 참조 연산을 잘못해서 다른 프로그램의 메모리 영역이나 커널 영역을 참조하게 될 수 있습니다. 이는 보안적인 문제인데, 이는 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 해결할 수 있습니다.
- 2개의 레지스터는 기준 레지스터와 한계 레지스터입니다. `기준 레지스터`에는 프로그램이 접근할 수 있는 가장 작은 주소가, `한계 레지스터`에는 프로그램이 접근할 수 있는 범위를 보관하고 있어서, "기준 레지스터에 있는 주소 ~ 기준 레지스터에 범위(한계 레지스터 값)을 더한 만큼"까지의 범위만을 프로그램이 접근할 수 있게됩니다.

### 11. CPU 보호

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 OS에서는 타이머(timer)라는 하드웨어를 사용합니다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜서 운영체제가 CPU의 제어권을 획득 할 수 있도록 합니다.
- 타이머는 매 클럭 틱(clock tick)마다 1씩 감소하고 0이되는 순간에 폭발합니다.

### 12. 시스템 콜을 이용한 입출력 수행

- 입출력은 특권명령에 해당하므로 사용자 프로그램이 직접 수행할 수 없습니다. 따라서 운영체제에게 시스템 콜을 요청하여 입출력을 수행하게 됩니다.
- 즉, `시스템 콜`은 입출력 명령을 사용하기 위한 인터페이스라고 볼 수 있습니다.

<br>
---
<br>

## 4장 프로그램의 구조와 실행

### 1. 프로그램의 구조와 인터럽트

- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야합니다. 이때 프로그램의 주소 영역은 코드, 데이터, 스택 영역으로 구분됩니다.
- `코드(code) 영역`은 우리가 작성한 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 저장되는 부분이고,
- `데이터(data) 영역`은 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이며,
- `스택(stack) 영역`은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간입니다.

### 2. 컴퓨터 시스템의 작동 개요

- `프로그램 카운터(Program Counter: PC)`란, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 의미합니다. CPU는 매번 PC가 가리키는 메모리 위치의 명령을 처리합니다.

### 3. 프로그램의 실행

- 각각의 프로세스는 자신만의 물리적인 메모리 주소 공간을 갖습니다. 그리고 이 주소 공간 안에서 코드 영역, 데이터 영역, 스택 영역을 가지는데, 이처럼 프로그램마다 독자적으로 존재하는 주소공간을 `가상 메모리`라고 합니다.
- 운영체제 커널 역시 코드 영역, 데이터 영역, 스택 영역을 가집니다.
- 커널의 코드 영역은 CPU와 메모리 자원관리 같은 역할을 하는 부분이 주를 이루며,
- 데이터 영역에는 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB를 두고 있습니다.
- 커널의 스택 영역에는 현재 수행 중인 프로세스마다 별도의 수택을 두어 관리하는데, 프로세스가 시스템 콜을 호출하였을 때 시스템 콜에서 호출하는 함수들의 주소를 보관하여 호출 이후 다시 복귀하기 위함입니다.

### 4. 사용자 프로그램이 사용하는 함수

- 프로그램이 사용하는 함수는 크게 3가지로, 사용자 정의함수, 라이브러리 함수, 커널 함수가 있습니다.
- 사용자 정의 함수는 개발자가 직접 작성한 함수를, 라이브러리 함수는 다른 개발자가 작성해 놓은 함수를 사용하는 것을 의미하며, 두 가지 모두 해당 프로그램의 코드 영역에서 관리됩니다.
- 하지만 커널 함수의 경우에는 운영체제 커널의 주소 공간에 코드가 정의됩니다.

### 5. 인터럽트

- CPU는 프로그램 카운터가 기리키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에, 현재 수행 중인 프로세스로부터 CPU를 회수하여 다른 프로세스에세 CPU를 할당하기 위해서는 인터럽트 매커니즘이 필요합니다.

### 6. 시스템 콜

- 프로그램이 CPU를 할당 받고 명령을 수행하다가 중간에 CPU를 빼앗기는 경우는 두 가지 경우입니다. 첫번째는 타이머 인터럽트에 의해 빼앗기는 경우이고, 두번째는 시스템 콜로 인해 CPU를 빼앗기는 경우입니다. 시스템 콜을 통한 작업은 시간이 오래걸리므로(예를들면 입출력) 해당 프로세스를 Block 상태로 만들어 놓은 뒤 다른 프로세스에게 CPU를 넘겨주어 CPU가 놀지 않도록 합니다.

### 7. 프로세스의 두 가지 실행 상태

- 프로세스의 실행 상태는 `사용자 모드에서의 실행 상태`와 `커널 모드에서의 실행 상태`로 나뉩니다. 프로세스가 일반적으로 실행중일 때는 사용자 모드에서 실행되지만 시스템 콜을 사용하게되면 커널 모드로 스위칭되어 커널 모드에서의 실행 상태가 됩니다. 이때, CPU는 운영체제에게 빼앗기긴하지만 결국 해당 시스템 콜로 인한 작업 역시 해당 프로세스를 위한 작업이므로 실행 상태로 간주합니다.

<br>
---
<br>

## 5장 프로세스 관리

### 1. 프로세스의 개념

- 프로세스란 실행 중인 프로그램을 뜻합니다.
- 여러개의 프로세스가 수행되는 시분할 시스템 환경에서는 프로세스들이 인터럽트에 의해서 CPU를 사용하다가 뺏기다가 사용하다가 뺏기다가를 반복하게 됩니다. 이 때, 다시 자신의 수행하던 시점부터 프로세스를 이어나가기 위해서는 해당 프로세스에 대한 정보가 필요한데, 이를 `프로세스 문맥`이라고 합니다.
- 프로세스 문맥에는 해당 프로세스의 주소 공간, 레지스터에 어떤 값을 가지고 있었는지, 시스템 콜 등을 통해 커널에서 수행한 일의 상태, 해당 프로세스에 대해 커널이 관리하는 각종 정보들 등이 포함되어 있습니다.

### 2. 프로세스의 상태

- 프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지 상태로 구분할 수 있습니다.
- `실행 상태(running)`는 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태를 의미합니다.
- `준비 상태(ready)`는 프로세스가 CPU만 할당받기만 하면 당장 명령을 실행할 수 있는 상태를 의미합니다.
- `봉쇄 상태(blocked, wait, sleep)`는 CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태를 말합니다. 예시로는 입출력 처리중인 프로세스가 있습니다.
- 이 외에도 프로세스가 생성중이라면 `시작 상태(new)`, 프로세스가 종료 중이라면 `종료 상태(terminated)`라는 용어도 있습니다.

### 3. 프로세스 제어블록 (PCB)

- 프로세스 제어블록(PCB)이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해, 각각의 프로세스마다 해당 프로세스의 정보를 저장하는 커널 내의 자료구조를 말합니다.
- PCB는 다음과 같은 요소들로 구성되어있습니다.
  - 프로세스의 상태
  - 프로그램 카운터 값
  - CPU 레지스터 값
  - CPU 스케줄링 정보
  - 메모리 관리 정보
  - 자원 사용 정보
  - 입출력 상태 정보

### 4. 문맥교환

- `문맥 교환`이란 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고, 새로운 프로세스로 CPU를 이양하는 과정을 말합니다.

### 5. 프로세스를 스케줄링하기 위한 큐

- 커널의 데이터 영역에는 다양한 큐를 두어 프로세스의 상태를 관리합니다. 대표적인 큐들은 다음과 같습니다.
- 어떤 프로세스에게 CPU를 할당할 것인지를 처리하기 위해 준비 큐(ready queue)를 사용합니다.
- 특정 자원을 기다리는 프로세스들을 처리하기 위해 장치 큐(device queue)를 사용합니다. 예를 들면 디스크 입출력 큐가 있습니다.
- 공유 데이터에 접근하고자 하는 프로세스들에 대해서도 큐를 사용하게 됩니다.

### 6. 스케줄러

- 스케줄러랑 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드 영역을 말합니다. 그리고 스케줄러에는 장기 스케줄러와 단기 스케줄러가 있습니다.
- `장기 스케줄러`는 어떤 프로세스를 준비 큐에 넣을지를 결정하는 역할을 합니다. 준비 큐에 프로세스가 있다는 것은 CPU만 할당받으면 실행할 수 있다는 의미이므로, 준비 큐에 넣기전에 메모리 공간을 확보하는 등의 과정이 선행돼야 합니다.  
  (장기 스케줄러는 현대의 시분할 시스템용 운영체제에서는 사용하지 않는다고 합니다. 바로바로 준비 큐에 넣어준다네요)
- `중기 스케줄러`는 너무 많은 프로세스에게 메모리를 할당해주어서 시스템 성능이 저하되는 경우, 이를 해결하기 위해 메모리에 적재된 프로세스들 중 어떤 프로세스를 스왑아웃 할지 결정하는 역할을 합니다.  
  (1순위는 봉쇄 상태에 있는 프로세스라고 합니다)
- `단기 스케줄러`는 CPU 스케줄러라고도 하며, 준비 상태의 프로세스들 중 어떤 프로세스를 다음에 실행할 지를 결정합니다.

### 7. 프로세스의 생성

<br>

### 8. 프로세스 간의 협력

- `IPC(Inter-Process Communication)`란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스간의 통신과 동기화를 이루기 위한 매커니즘입니다. IPC의 대표적인 방법으로는 메시지 전달 방식과 공유메모리 방식이 있습니다.
- `메시지 전달 방식`은 프로세스 간에 공유 데이터를 사용하지 않고 커널을 경유해 메시지를 주고 받는 방법입니다. 커널을 경유하는 이유는, 다른 프로세스가 원치 않는 메시지를 전달해 악영향을 미치는 상황을 피하기 위해서 메세지를 주고 받는 연산을 특권명령으로 규정해두었기 때문입니다.
- `공유 메모리 방식`은 운영체제가 지원하는 공유 메모리 시스템 콜을 사용하여 각자의 주소 공간에 공통적으로 포함되는 영역을 읽고 쓸 수 있게 할 수 있습니다. 이 방식을 사용할 때는 공유 메모리 내부에 있는 데이터에 대해서는 커널이 책임지지 않기 때문에 직접 동기화 문제를 해결해야 합니다.

<br>
---
<br>

## 6장 CPU 스케줄링

### 1. CPU 스케줄러

- CPU 사용을 잦게 하는 프로세스를 CPU 버스터 비율이 높은 프로세스라 하며 `CPU 바운드 프로세스`라고 합니다.
- I/O 작업을 잦게 하는 프로세스를 I/O 버스터 비율이 높은 프로세스라 하며 `I/O 바운드 프로세스`라고 합니다. (대화형 프로그램)
- 일반적으로 CPU 바운드 프로세스는 CPU를 길게 가지는 연산을 주로 처리하는 프로세스이고, I/O 바운드 프로세스는 대부분 대화형 프로세스이므로, 빠른 응답이 필요한 대화영 프로세스에게 CPU를 우선적으로 할당하는 스케줄링이 필요합니다.
- CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드를 말합니다.
- CPU 스케줄링 방식에는 선점형과 비 선점형 방식이 있습니다.

### 2. 디스패처

- `디스패처(dispatcher)`란, CPU를 이양받기로 선택된 프로세스가 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 말합니다.
- 디스패처는 현재 수행중이던 프로세스의 문맥을 해당 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 이양하는 과정을 수행합니다.

### 3. 스케줄링의 성능 평가

- 스케줄링 기법의 성능을 평가하기 위한 지표는 시스템 관점의 지표와 사용자 관점의 지표로 나뉩니다.
- 시스템 관점의 지표로는 CPU 이용율과 처리량이 있으며,
- 사용자 관점의 지표로는 소요시간, 대기시간, 응답시간이 있습니다.

### 4. 스케줄리 알고리즘

- `FCFS(First-Come First-Service)` 스케줄링은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말합니다. 콘보이 효과가 발생할 수 있다는 단점이 있습니다.
- `SJF(Shortest-Job First)` 스케줄링은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말합니다. 이 방식은 평균 대기시간을 가장 짧게 할 수 있는 최적 알고리즘입니다. SJF에는 선점형 방식과 비선점형 방식이 있는데, 선점형 구현 방식을 SRTF(Shortest Remaining Time First)라고 합니다. 기아 현상이 발생할 수 있다는 단점이 있습니다.
- `우선순위(priority)` 스케줄링은 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말합니다.  
  (HRRN이 여기에 해당되는 것 같네요)
- `라운드 로빈(Round Robin)` 스케줄링은 시분할 시스템의 성질을 잘 활용한 스케줄링 방식으로, 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 정해놓고(time quantum), 이 시간이 경과하면 다음 프로세스에게 CPU를 할당하는 비선점 스케줄링 방식입니다. 라운드 로빈 스케줄링에서는 time quantum을 잘 조절해주는 것이 중요합니다.
- `멀티레벨 큐(Multilevel Queue)`는 일반적으로 성격이 다른 프로세스들을 별도로 관리하고, 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비큐를 별도로 두는 방식입니다. 예를들어 빠른 응답을 필요로하는 대화영 작업과 그렇지 않은 작업을 별도의 큐로 관리한다면, 대화형 작업이 기다리는 경우에는 해당 큐에 우선적으로 CPU를 할당하며, 아닐때는 다른 큐에 우선적으로 CPU를 할당합니다.
- `멀티레벨 피드백 큐(Multilevel Feedback Queue)`는 여러 레벨의 큐를 두고, 프로세스가 큐를 이동하는 방식입니다. 예를들어 aging 기법에 의해 우선순위가 높아진 프로세스는 지금보다 우선순위가 더 높은 큐로 이동하는 방식입니다.

<br>
---
<br>

## 7장 메모리 관리

### 1. 주소 바인딩

- 프로세스는 자신만의 독자적인 주소공간인 논리적 주소, 혹은 가상 주소를 가지고 있고, 물리적으로 메모리 상 어디에 위치하는지를 의미하는 물리 주소 역시 가지고 있습니다. 이때, 논리적 주소를 통해 메모리를 참조하게 되면, 해당 논리적 주소가 물리적 주소의 어느 위치에 매핑되어 있는지를 확인해야 하는데 이렇게 프로세스의 논리적인 주소를 물리적 메모리 주소로 연결시켜주는 작업을 `주소 바인딩`이라고 합니다.
- `MMU(Memory Management Unit) 기법`은 CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때, 그 논리적 주소값에 기준 레지스터의 값을 더해 물리 주소값을 얻어냅니다. 이때 기준 레지스터는 재배치 레지스터라고 하기도 하며, 3장에서 살펴보았듯이 프로세스의 물리적 메모리 시작주소를 가집니다.

### 2. 메모리 관리와 관련된 용어

- `동적로딩`은 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 모두 올려놓는 것이 아니라 해당 부분이 불릴 때만 올려놓기 때문에 보다 효율적으로 메모리를 사용할 수 있습니다. 예를 들어 에러처리와 같은 코드들을 실제로 많이 사용되지 않으므로 내려놓고 있다가 필요할 때만 올리게됩니다.
- `동적연결`은 라이브러리 함수가 호출되는 시점에 라이브러리에 대한 연결이 이루어집니다. 동적연결은 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있습니다.
- `중첩(overlay)`란 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법입니다. 동적로딩과는 개념적으로 유사하나 사용하는 이유가 다릅니다. 중첩은 초창기 컴퓨터 시스템에서 물리적 메모리가 부족한 상황으로 인해 하나의 프로세스조차도 메모리에 올릴 수 없을 때 사용하던 기법인 반면, 동적로딩은 다중프로그래밍 환경에서 메모리 이용률을 높이기 위해서 사용하는 기법입니다.
- `스와핑(swapping)`이란 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(= 백킹스토어: backing store)에 일시적으로 내려놓는 것을 말합니다. 스와핑은 swap in과 swap out으로 나뉘며, 중기 스케줄러에 의해 발생합니다.

### 3. 물리적 메모리의 할당 방식

- 연속할당 방식은 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 하는 방식이며, 불연속할당 방식은 하나의 프로세스를 물리적 메모리의 여러 영역에 반순해 적재하는 방식입니다.
- `연속할당 방식 - 고정분할, 가변분할`
  - 고정분할은 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행하는 방식입니다. 내부조각과 외부조각이 발생할 수 있다는 단점이 있습니다.
  - 가변분할은 고정분할과 달리 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식입니다. 가변분할은 내부조각이 발생하지 않지만 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부조각이 발생할 가능성이 있습니다. 이런 가변 분할에서는 물리적 메모리 내의 가용 공간 중 어떤 위치에 올릴것인지 결정하는 문제(동적 메모리 할당 문제)를 고려해야 하는데, 이에 대한 방법으로 최초적합, 최적적합, 최악적합이 있습니다.
- `불연속할당 방식 - 페이징, 세그먼테이션, 페이지드 세그먼테이션`

### 4. 페이징 기법

- 페이징 기법이란 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누고, 메모리 역시 페이지와 동일한 크기의 프레임으로 나누어서, 이 프레임에 페이지를 적재하는 방식을 말합니다. 어떤 위치이든 상관 없이 빈 프레임이 있기만하다면 페이지를 적재하면 되므로, 메모리의 동적 할당 문제가 발생하지 않는다는 장점이 있습니다.
- 페이지는 불연속할당 방식이므로 페이지 별로 메모리 상 어디에 적재되어 있는지에 대한 정보가 필요한데, 이렇게 페이지가 물리적 메모리의 몇 번째 프레임에 들어있다는 정보를 `페이지 테이블`에 저장합니다.
- 페이지 테이블에 접근하기 위해서 운영체제는 `페이지 테이블 기준 레지스터`와 `페이지 테이블 길이 레지스터`를 갖습니다. 기준 레지스터는 메모리 내의 페이지 테이블의 시작 위치를 가리키며, 길이 레지스터는 페이지 테이블의 크기를 보관합니다.
- 페이징 기법에서 메모리에 접근하기 위해서는 페이지 테이블에 접근해서 물리주소를 알아내는 것과, 이 물리주소를 통해 실제 데이터에 접근하는 2가지 과정이 소요됩니다. 따라서 이렇게 두 번 접근해야 하는 오버헤드를 줄이고 메모리의 접근 속도를 향상시키기 위해 TLB라는 고속의 주소 변환용 하드웨어 캐시가 사용되기도 합니다.

### 5. 세그먼테이션

- 세그먼테이션은 프로세스의 주소 공간을 의미있는 단위인 세그먼트로 나누는 방법입니다. 일반적으로 세그먼트는 "코드, 데이터, 스택"으로 나뉘게 되며, 세그먼트는 크기가 균일하지 않습니다.
- 세그먼테이션 역시 주소 변환을 위해 `세그먼트 테이블`을 사용하며, 세그먼트 테이블의 각 항목은 기준점(base)과 한계점(limit)을 갖습니다. 기준점은 세그먼트의 시작 위치를, 한계점은 세그먼트의 길이를 나타냅니다.
- 페이지와 마찬가디로 세그먼테이션 기법 역시 세그먼트 테이블에 접근하기 위해서 `세그먼트 테이블 기준 레지스터`와 `세그먼트 테이블 길이 레지스터`를 사용합니다. 기준 레지스터는 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블의 시작 주소를 가지며, 길이 레지스터는 해당 프로세스의 주소 공간이 총 몇 개의 세그먼트로 나뉘어져 있는지를 나타냅니다.

### 6. 페이지드 세그먼테이션

- 페이지드 세그먼테이션은 먼저 프로그램을 의미있는 단위의 세그먼트로 나누고, 이 세그먼트를 동일한 크기의 페이지들의 집합으로 구성하는 기법입니다.
- 즉, 페이지드 세그먼테이션 기법에서는 하나의 세그먼트의 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼트 기법에서 발생하는 외부조각 문제를 해결하며, 동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소합니다.
- 페이지드 세그먼테이션 기법에서는 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블을 필요로합니다.

<br>
---
<br>

## 8장 가상메모리

### 1. 요구 페이징

- 요구 페이징이란 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 게 아니라 당장 사용될 페이지만을 올리는 방식입니다.
- 요구 페이징에서는 특정 페이지가 메모리에 존재하는지 아닌지에 대한 여부를 판단하는 것이 필요한데 이는 페이지 테이블에 유효-무효 비트를 통해 파악하게 됩니다.
- 페이지가 부재일 경우 요구 페이징은 다음과 같이 처리합니다.
  - 먼저 CPU가 페이지를 참조하기 위해 페이지 테이블을 봤더니 해당 페이지가 무효비트이면 이는 페이지 부재 상태입니다.
  - 그러면 이제 빈 프레임을 찾아서 그곳에 페이지를 읽어오게 됩니다. 만약에 빈 프레임이 없다면 메모리에 올라와있는 페이지 중 하나를 스왑아웃 시킵니다.
  - 이 때, 페이지를 디스크로부터 메모리로 적재하기까지에는 많은 시간이 소요되므로, 페이지 부재를 발생시킨 프로세스는 CPU를 빼앗기고 봉쇄상태가 됩니다.
  - 디스크 입출력(페이지를 올리는 과정)이 완료되면 인터럽트가 발생하고 페이지 테이블에서 해당 페이지의 유효-무효 비트를 유효로 변경합니다.
- 요구 페이징의 성능을 올리기 위해서는 페이지 부재율을 낮추도록 해야합니다.

### 2. 페이지 교체

- 페이지 부재가 발생했는데 메모리에 빈 프레임이 없는 경우 페이지를 교체해야합니다. 이때 어떻게하면 페이지 부재율을 최소화할 수 있을지에 대한 내용이 페이지 교체 알고리즘입니다.
- `최적 페이지 교체` 알고리즘은 현재 물리적 메모리에 존재하는 페이지들 중 가장 먼 미래에 참조될 페이지를 쫓아내는 방식을 말합니다. 이는 가장 페이지 부재율을 낮추는 알고리즘이지만 현실에서 불가능한 알고리즘으로, 다른 알고리즘들의 성능 평가의 잣대로 사용됩니다.
- `선입선출(FIFO)` 알고리즘은 페이지 교체 시 먼저 메모리에 올라간 페이지를 먼저 내쫓는 방식입니다. 페이지의 향후 참조 가능성을 고려하지 않기 때문에 비효율적인 상황이 발생할 수 있습니다.
- `LRU(Least Recently Used)` 알고리즘은 페이지 교체 시 가장 오랫동안 참조가 이루어지지 않은 페이지를 쫓아내는 방식입니다.
- `LFU(Least Frequently Used` 알고리즘은 물리적 메모리 내에 존재하는 페이지들 중에서 과거에 참조된 횟수를 고려하여 가장 적었던 페이지를 쫓아내는 방식입니다. LRU 알고리즘에 비해 오랜 시간 동안의 참조 기록을 반영할 수 있다는 장점이 있으나, 같은 이유로 시간에 따른 페이지 참조 변화를 반영하지 못한다는 단점도 존재합니다.
- `클럭(Clock)` 알고리즘은 오랫동안 참조되지 않은 페이지들 `중` 하나를 교체하는 알고리즘으로, 하드웨적인 자원을 통해 운영 오버헤드를 줄인 방식입니다. 클럭 알고리즘은 마치 시계바늘이 지나가듯이 페이지들의 참조비트를 순차적으로 조사하여 참조비트가 1인 페이지는 0으로 바꾼 후 지나가고, 0인 페이지는 교체합니다.  
  LRU와 근사한 알고리즘이지만 하드웨어적인 지원으로 동적하므로 훨씬 빠르고 효율적입니다. 따라서 대부분의 시스템에서는 페이지 교체 알고리즘으로 클럭 알고리즘을 채택합니다.

### 3. 페이지 프레임의 할당

- 각 프로세스에게 얼마만큼의 메모리 공간을 할당할 것인지를 정해야 하는데 이를 위해 할당 알고리즘을 사용합니다.
- `균등할당` 방식은 모든 프로세스에게 페이지 프레임을 균일하게 할당합니다.
- `비례할당` 방식은 프로세스의 크기를 고려하여 이에 비례하게 할당하는 방식입니다.
- `우선순위 할당`은 당장 CPU에서 실행될 프로세스에게 우선적으로 페이지를 할당하는 방식입니다.

### 4. 전역교체와 지역교체

- 교체 대상인 프레임의 범위를 어떻게 할지에 따라 전역교체와 지역교체로 나뉩니다. 전역교체는 해당 프로세스뿐만 아니라 모든 페이지 프레임이 교체 대상이 될 수 있는 방법이고, 지역교체는 해당 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정하는 방법입니다.
- 집중적으로 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못하면, 페이지 부재율(page fault rate)이 크게 상승해 디스크 I/O 작업이 발생하게되고, 이로인해 CPU 이용율이 급격히 떨어질 수 있는데, CPU 이용율이 떨어지면 운영체제는 다중 프로그래밍 정도를 높이려고 합니다. 그렇게 되면 오히려 다시 페이지 부재율은 높아지게 되고 다시 CPU 이용율이 떨어지는 악순환이 발생합니다. 결국 실제 CPU 사용 시간보다 페이지 교체에 시간이 더 많아질 수 있는데 이와 같은 현상을 `스레싱`이라고 합니다.
- 이러한 스레싱을 예방하는 방법에는 워킹셋 알고리즘(Working set)과 페이지 부재 빈도 알고리즘(PFF)가 있습니다.
- 프로세스는 특정 주소 영역을 집중적으로 참조하는 경향이 있습니다. 이렇게 집중적으로 참조되는 페이지들의 집합을 지역성 집합이라고 하는데, `워킹셋 알고리즘`은 이와같은 지역성 집합이 한꺼번에 메모리에 올라갈 수 있도록 하는 알고리즘입니다.
- `페이지 부재 빈도 알고리즘`은 프로세스의 페이지 부재율을 주기적으로 조사하고 이 값에 근거하여 각 프로세스에게 할당할 메모리 양을 동적으로 조절합니다. 어떤 프로세스의 페이지 부재율이 미리 정해놓은 상한값을 넘게되면 이 프로세스는 프레임 수가 부족하다고 판단하여 프레임을 더 할당하며, 하한값 이하로 떨어지면 너무 많은 프레임이 할당된 것으로 간주해 프레임을 빼앗습니다.  
  이런 방식으로 메모리 내에 존재하는 모든 프로세스에게 필요한 프로세스를 다 할당한 후에도 프레임이 남는 경우 스왑 아웃되었던 프로세스에게 프레임을 할당하여 다중프로그래밍정도(MPD)를 높이고, 이를 통해 스레싱을 예방합니다.
