---
title: (2020-06-28) JavaScript 2 x n 타일링
date: 2020-06-28
tag: [TDD]
---

## 이해

- 2 x 2 의 공간을 타일로 채우는 방법은 타일을 가로로 배치하는 경우와 세로로 배치하는 경우로 총 2가지 방법이 있다.
- 이 때, 2 x n 의 공간을 타일로 채우는 방법의 수를 return 하라.

## 계획

- 규칙을 찾아보자.
- 가로 블럭 묶음이 없을 경우, 블럭은 총 6개로 볼 수 있다.
  6개가 자리를 찾는 경우의 수는 6!, 근데 모두 같은 블럭이므로 6!로 나눈다.
- 가로 블럭 묶음이 1개일 경우, 블럭은 총 5개로 볼 수 있다.
  5개의 블럭이 자리를 찾는 경우의 수는 5!, 근데 세로블럭 4개가 같은 블럭이므로 4!로 나눈다.
- 가로 블럭 묶음이 2개일 경우, 블럭은 총 4개로 볼 수 있다.
  4개의 블럭이 자리를 찾는 경우의 수는 4!, 근데 세로블럭 2개와 가로블럭묶음 2개가 같은 블럭이므로 2! * 2로 나눈다.
- 가로 블럭 묶음이 3개일 경우, 블럭은 총 3개로 볼 수 있다.
  3개의 블럭이 자리를 찾는 경우의 수는 3!, 근데 가로블럭묶음 3개가 같은 블럭이므로 3!로 나눈다.
- 규칙은 가로 블럭 묶음이 x 개일 때, 블럭은 총 (n - x)개로 볼 수 있다.
  이때, (n - x)개의 블럭이 자리를 찾는 경우의 수는 (n - x)!, 근데 가로블럭 묶음 x개가 같은 묶음이고, 세로블럭 (n - (x * 2))개가 같은 묶음이므로 x!과 (n - (x * 2))!로 나눈다.
- 즉, 가로 블럭 묶음 x개의 경우의 수는 (n - x)! / (x! * (n - (x * 2))!)이며, 가로블럭 x개는 parseInt(n / 2)개 만큼까지 가능하다.

<br>

- 근데 위의 방식은 안된다.
- 왜냐하면 factorial을 직접 만들어서 사용하는데 factorial에 300정도만 들어가도 값이 너무 커져서 NaN이 뜨기 때문이다. 문제의 요구사항대로라면 최대 60,000까지 들어갈 수 있어야 한다.
- 근데 그냥 이 문제의 결과 값은 피보나치로 나온다. 다른 규칙은 다 찾고 결과 값이 피보나치 형식이라는 규칙은 눈 앞에 두고 못찾다니...

<br>

- 그래서 재귀를 사용한 피보나치로 풀었다.
- 안된다.
- 재귀는 값이 커졌을 때 효율이 구리니깐.

<br>

- 그래서 for 문을 이용한 피보나치로 풀었다.
- 잘 풀린다. 갓 for 문

## 실행

```javascript
const solution = (n) => pibonaci(n + 1);

const pibonaci = (n) => {
  let previous = 0;
  let current = 1;

  for (let i = 0; i < n; i += 1) {
    let next = (previous + current) % 1000000007
    previous = current
    current = next
  }

  return previous;
}

test('solution', () => {
  expect(solution(4)).toBe(5);
  expect(solution(5)).toBe(8);
  expect(solution(6)).toBe(13);
});
```

## 회고

- 처음에는 무슨 이딴 문제가 다있나 하고 문제에 대한 욕을 했었지만, 재귀의 효율에 대한 경각심을 느끼게 해준 문제인 것 같다.
- 지금까지 재귀가 for문에 비해 효율이 안좋다는 사실도 알고있었고, 스택이 그렇게 크지 않아서 조금만 많이 쌓여도 stack overflow가 발생한다는 사실도 알고있었지만, 근래에 재귀를 활용한 BFS와 완전탐색으로 너무 꿀을 많이 빨아서 재귀를 맹신하고 있었다.
- 이번 문제로 인해 다시금 재귀를 사용할 때 무분별하게 쓰는 것이 아니라 사용하는 경우를 신중하게 선택해야 한다는 것을 깨닫게 되었다.
- 그리고 규칙을 찾을 때 좀 거시적으로 바라볼 필요성을 느낀 것 같다.
- 나름 배운 게 많았다. 좋은 문제인 것 같다.
