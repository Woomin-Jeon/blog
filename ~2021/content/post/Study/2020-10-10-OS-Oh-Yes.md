---
title: OS? Oh Yes - 운영체제 스터디 정리
date: 2020-10-10
category: "All"
draft: true
---

"OS? Oh Yes"라는 책과 운영체제 스터디를 통해 제가 알게된 지식들을 QnA 형태로 정리하였습니다.

<br><br>

### 부팅 과정을 설명하시오.

- 먼저 PC 전원을 키게되면 메인보드 위에 있는 플래시 ROM에 저장된 BIOS 명령에 의해 이후 동작을 수행합니다. BIOS에는 메모리나 하드디스크 등의 주변기기에 대해 POST(Power On Self Test)를 진행힙니다. POST 처리가 끝나면 BIOS는 CPU에 대해 하드디스크 맨 앞에 있는 MBR(Master Boot Record)를 읽도록 명령합니다. MBR에는 하드디스크에 저장되어있는 OS를 메인메모리로 저장하기 위한 수순인 부트 로더(Boot Loader)프로그램이 기술되어 있어서 이 단계에서 OS는 메인메모리에 로드됩니다. 그리고 이제 CPU는 메인 메모리상의 OS를 구동시키게 됩니다.

### 인터럽트에 대해 설명하시오.

- 인터럽트란 CPU가 컴퓨터 시스템에 존재하는 각 자원들의 현 상황을 파악하는 방법 중 하나로, 각 자원들이 능동적으로 자신의 상태변화를 CPU에게 알리는 방식입니다.

### 중첩된 인터럽트에 대한 처리는 어떻게 하는지 설명하시오.

- 중첩된 인터럽트에 대한 처리는 두 가지 방식이 있는데, 첫 번째는 순차적 처리로, 현재 처리 중인 인터럽트를 마저 처리한 뒤 다음 인터럽트를 처리하는 방식이고, 두 번째는 인터럽트의 중요도에 따라 우선순위를 매기고 이에 따라 처리하는 방식입니다.

### 인터럽트의 처리 과정을 설명하시오.

- 먼저 실행중이던 프로그램을 중단합니다. 그리고 인터럽트 처리 후 다시 실행될 때를 위해 PSW, PC 레지스터의 값 등을 시스템 스택에 저장합니다. 다음으로 인터럽트 처리 루틴의 시작 주소를 PC에 넣어 실행시킵니다. 인터럽트의 처리가 끝나면 PSW와 PC 값들을 다시 원래 자리에 넣어줍니다. 이렇게 되면 PC 값이 자연스럽게 기존에 실행중이턴 프로그램의 PC값이 되므로 해당 프로그램을 이어서 실행합니다.

### 타이머 인터럽트에 대해서 예를 들어 설명하시오.

- 타이머 인터럽트란 프로세스를 실행하기 전에 프로세스마다 타이머를 지정해줘서 CPU 클럭마다 1씩 감소시켜 줍니다. 그리고 이 타이머가 0이되면 프로세스가 중단됩니다. 타이머 인터럽트를 사용하면, 프로세스가 무한루프를 돌면서 쓸 데 없는 작업을 하는 경우를 막을 수 있습니다. 

### 잦은 하드웨어 인터럽트로 인해 CPU의 효율이 떨어질 수 있다. 이를 해결하기 위한 방법은 무엇이 있는가?

- DMA를 사용하면 됩니다. DMA(Direct Memory Access)란 키보드와 마우스 같은 주변 장치들이 CPU의 개입 없이 메모리에 직접 접근하여 읽거나 쓸 수 있게 하는 기능입니다. 즉, 하드웨어 인터럽트에 대해 DMA가 CPU의 연산을 대신 해주고 완료한 작업에 대해 인터럽트를 발생시킵니다.

### 시스템 콜(System call)이란 무엇인지 설명하시오.

- 시스템 콜(system call)이란 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스입니다.

### 운영체제의 이중 동작 모드란 무엇인지 설명하시오.

- 이중 동작 모드는 운영체제를 보호하기 위한 기법입니다. 사용자와 운영체제는 시스템 자원을 공유하는데, 사용자에게 제한을 두지 않으면 사용자가 메모리 내의 운영체제 자원을 망가뜨릴 위험이 있습니다. 그렇기 때문에 이를 보호하기 위해 사용자 모드와 관리자 모드(커널 모드)로 나누어 사용자의 시스템 자원 접근을 제한하는 장치가 이중 동작 모드입니다.

### 쓰레드에 대해 설명하시오.

- 프로세스는 부여받은 자원들의 소유자로서 작은 일들을 각각의 자신만의 실행환경을 가지는 실행 단위로 세분화 할 수 있는데 이를 쓰레드라고 합니다.

### 쓰레드 세이프(Thread saft)에 대해 설명하시오.

- 쓰레드 세이프란, 쓰레드가 멀티쓰레드 환경에서 동작하더라도 일반적인 함수나 변수, 혹은 객체가 여러 쓰레드들로부터 동시 접근이 이루어져도 프로그램 실행에 문제가 없는 것을 말합니다.

### 유저 레벨 쓰레드와 커널 레벨 쓰레드의 차이를 설명하시오.

- 유저 레벨 쓰레드는 스레드 라이브러리에 의해 관리되며, 스레드와 관련된 모든 행위는 사용자 공간에서 이루어지므로 커널은 쓰레드의 존재를 알지 못합니다. 반면, 커널 레벨 쓰레드는 모든 쓰레드의 관리를 커널이 하는 것을 말합니다.
유저 레벨 쓰레드는 쓰레드 스위칭에 커널의 개입이 필요 없어서 모드 스위칭이 필요 없으므로, 어떤 운영체제에서도 운영 가능하다는 장점이 있으며, 특정 쓰레드의 대기가 자신이 소속된 프로세스 내의 모든 쓰레드의 대기를 초래한다는 단점이 있습니다. 또한, 커널이 쓰레드를 보지 못하기 때문에 프로세스 단위로만 CPU를 할당하여 다중 처리 환경이 주어진 다 해도 쓰레드 단위의 다중처리를 할 수 없습니다.
커널 레벨 쓰레드는 커널이 모든 쓰레드를 알고있기 때문에 각 쓰레드가 처리기를 할당 받아 병렬 실행이 가능하며, 특정 쓰레드의 대기가 다른 쓰레드의 대기를 초래하지 않습니다. 하지만 같은 프로세스에 속한 쓰레드간의 스위칭에도 커널이 개입되기 때문에 모드 스위칭이 요구되어 성능이 떨어지는 단점이 있습니다.

### 스택을 쓰레드마다 독립적으로 할당하는 이유는 무엇인가?

- 쓰레드별로 각각의 독립된 함수를 실행시킬 필요가 있기 때문입니다.

### 프로세스에 대해 설명하시오.

- 프로세스란 프로그램과 데이터를 기본으로 정상적인 실행을 위해 필요한 환경을 시스템으로부터 부여받은 능동적인 존재입니다.

### 프로세스의 상태 변화에 대해 설명하시오.

- 생성(Created) 상태에서 사용자가 요청한 작업이 커널에 등록되고 PCB가 만들어져 프로세스가 만들어집니다. 
- 그 다음 준비(Ready) 상태에서 CPU를 할당받기 위해 대기합니다. 이 때, Ready 상태에 있는 프로세스들을 어떤 순서로 CPU를 할당할 지 정하는 것을 CPU 스케쥴링이라고 합니다. 
- 다음으로 CPU를 할당받으면 프로세스는 실행(Running) 상태가 됩니다. 이 때, CPU를 할당하는 작업을 디스패치(Dispatch)라고 합니다. 이렇게 실행중인 프로세스들은 CPU 스케쥴링에 의해 CPU를 뺏길 수도 있으며, 시간 할당량이 소진되어 인터럽트에 의해 뺏길 수도 있습니다. 이렇게 CPU를 빼앗긴 프로세스들은 대기 상태로 바뀝니다.
- 마지막으로 프로세스가 종료될 때 프로세스는 할당되었던 모든 자원들을 반납하고 PCB만 커널에 남아있게되는데 이 상태를 종료(Terminated) 상태라고 합니다.
만약 여기서 시간 종료(Timeout)에 따른 인터럽트가 발생하면 다시 준비 상태가 되어 자신의 차례를 기다리게 되며, I/O 작업이 발생하면 대기상태로 갔다가 입출력 처리가 종료되면 준비 상태가 되어 자신의 차례를 기다리게 됩니다.
- 보류(Suspend) 상태는 메모리가 더이상 없게되었을 때, CPU가 당분간 메모리를 회수해도 문제되지 않을 프로세스들을 골라서 메모리를 회수해서 이 회수된 프로세스들의 상태를 말합니다.

### I/O 인터럽트가 발생하면 프로세스가 대기(Blocked) 상태로 바뀌는 이유는 무엇인지 설명하시오.

- CPU는 비싼 자원이라 돌려야 합니다. 하지만 입출력이 완료될 때까지 CPU가 기다리게 되면 CPU가 놀게되므로, 이는 대기상태로 만들어서 컨트롤러에게 맡기고 컨트롤러가 처리를 완료하면 CPU에게 완료 신호(인터럽트)를 보내서 CPU가 이를 감지하고 프로세스를 준비(Ready)상태로 바꿉니다.

### 프로세스 제어 블록(PCB)에 대해 설명하시오.

- 프로세스 제어 블록(Process Control Block)이란, 프로세스의 모든 것을 표현하는 자료구조라고 볼 수 있습니다.

### PCB는 어디에 저장되는가?

- PCB는 커널에 저장되는데 자료구조이기 때문에 데이터영역에 저장됨 

### 프로세스간 통신을 하는 방법 두 가지를 설명하시오.

- 프로세스간 통신을 하는 방법은 IPC(Inter Process Communication)으로, 공유메모리 방식과 메세지 전달 방식이 있습니다. 공유 메모리 방식은 말 그대로 프로세스간 메모리를 공유하는 것이며, 메세지 방식은 OS가 커널 내부에 메세지를 기록할 수 있는 버퍼를 마련해 놓고 프로세스들이 시스템콜을 통해 메시지의 송 수신을 요청하는 방식입니다.

### 컨텍스트 스위칭(context switching)이란 무엇인지 설명하시오.

- 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해  기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업을 컨텍스트 스위칭이라고 합니다.

### CPU 스케줄링 알고리즘에 대해 설명하시오.

- **FCFS**: First Come First Service로, 먼저 온 순서대로 처리하는 방법입니다. CPU 요구량이 큰 프로세스가 먼저 오게되면 뒤에 있는 작은 프로세스들은 계속 기다려야 하므로 평균 응답시간이 늦어지는 단점이 있습니다.
- **SPN**: Shortest Process Next(Shortest Job First)로, 말 그대로 CPU 요구량이 가장 적은 것을 먼저 실행하는 것입니다. 앞선 FCFS의 단점을 보완할 수 있지만, 짧은 실행시간을 가진 프로세스들이 계속해서 온다면 긴 실행시간을 가진 프로세스는 무한 대기할 수 있다는 단점이 있습니다. (대안: Aging 기법 - 기다린 만큼 우선순위를 높임)
- **SRT**: Shortest Remaining Time으로, 선점 방식의 SPN이라고 볼 수 있습니다. 어떤 프로세스를 실행 중에도 더 짧은 프로세스가 온다면 이 짧은 프로세스에게 CPU를 할당합니다. 단점으로는, SPN보다 더 많은 문맥교환이 요구되어 평균 응답시간이 좀 더 길어질 수 있습니다.
- **HRRN**: Highest Response Ratio Next로, SPN과 SRT의 무한 대기 현상의 단점을 보완하는 방법입니다. 방법 자체는 응답률이 높은 프로세스에게 높은 우선순위를 주는 것으로, 프로세스의 대기시간이 높아질 수록 응답률이 높아집니다(Aging).
- **Round-Robin:** 라운드 로빈은 FCFS를 기반으로 하되, 각 프로세스가 한 번에 쓸 수 있는 CPU의 시간(타임 슬라이스)을 정해놓고, 할당된 시간이 끝나면 인터럽트에 의해 CPU를 빼앗아가는 방식입니다. CPU를 반환한 프로세스는 다시 Ready Queue에 들어가게 됩니다.

### 콘보이효과에 대해 설명하시오.

- 콘보이효과는 FCFS에서 발생하는 것으로, 엄청 긴 프로세스때문에 뒤에 짧은 프로세스들의 실행이 지연되어 효율이 떨어지는 현상을 말합니다.

### 선점 스케줄링과 비선점 스케줄링의 차이점을 설명하시오.

- 선점 스케줄링은 CPU를 할달방아 실행중인 프로세스로부터 CPU를 빼앗아(선점) 다른 프로세스에 할당하는 방식이며, 비선점 스케줄링은 한 프로세스가 CPU를 할당받으면 스스로 반납할때까지 사용하도록 허용하는 방식입니다.

### 선점형 스케줄링에서 주의해야할 점은 무엇인지 설명하시오.

- 선점형 스케줄링은 선점이 들어가기때문에 데이터의 동기화를 주의해야합니다.

### 동기와 비동기의 차이는 무엇인가?

- 동기는 요청한 결과가 나타난 뒤 다음으로 넘어가는 것(결과가 나타날때까지 대기)이며, 비동기는 요청에 대한 결과가 아직 안나오더라도 다른 작업으로 넘어가는 것을 말합니다.

### 동기화를 해야하는 이유에 대해서 설명하시오.

- 동기화를 해야하는 이유는 공유데이터에 여러 프로세스가 동시 접근했을 때 데이터 데이터 불일치로 인해 일관성이 망가질 위험이 있기 때문입니다.

### 상호 배제(Mutual Exclusion)에 대해 설명하시오.

- 상호 배제란 한 번에 하나의 프로세스만이 임계영역에 들어가야함을 의미합니다.

### 상호 배제를 위한 알고리즘에 대해서 아는대로 설명하시오.

- 먼저 데커(Dekker)의 알고리즘이 있는데, 이는 flag와 turn 변수를 적절히 사용하여 임계영역에 들어갈 프로세스를 정하는 방식입니다. 다음으로 피터슨(Peterson) 알고리즘은 데커의 알고리즘과 비슷한데 다른 프로세스에게 진입 기회를 양보해준다는 차이가 있습니다.
이와같이 데커와 피터슨의 알고리즘들은 두 프로세스 사이의 상호배제를 해결한 알고리즘입니다. 하지만 실제로는 이보다 많은 다수의 프로세스들 사이의 상호배제가 요구됩니다. 이렇듯 n개의 프로세스들을 대상으로하는 상호배제 기법으로는 다엑스트라(Dijkstra) 알고리즘이 있는데 무한대기가 발생할 위험이 있으며, 크누스(Knuth) 알고리즘은 지연시간이 커지는 단점이 있는 반면, Eisenberg와 Mcguire의 알고리즘은 유한 시간 내에 임계염역으로의 진입이 보장됩니다. 마지막으로 베이커리(Bekery - Lamport) 알고리즘도 있습니다.

### 임계영역(critical section)에 대해 설명하시오.

- 임계영역이란 병렬 컴퓨팅에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말합니다.

### 임계영역의 프로그램적 해결 방법의 충족 조건 3가지를 설명하시오.

- 첫 번째로 한 번에 하나의 프로세스만이 임계영역에 들어가야함(상호배제)을 지켜야하며,
- 두 번째로 임계영역에 있지 않은 프로세스가 다른 프로세스의 임계영역의 진입을 막아서는 안되며,
- 세 번째로 비어있는 임계영역에 대한 진입은 바로 허용하되, 특정 프로세스의 진입 시도가 계속 무산되어 기아를 겪지 않도록 해야합니다.

### Busy Waiting(Spin Lock)이 무엇인지 설명하고, 이 문제점을 보완하기 위해 나온 것이 무엇인지 설명하시오.

- Busy Waiting은 while 무한 루프를 계속 돌면서 공유자원을 사용할 수 있는 지 없는 지 계속 확인하는 방법입니다. 하지만 이 방법은 쓸데 없이 CPU를 낭비하기 때문에 이런 낭비를 해소하기 위해 세마포어가 나왔습니다. 만약 lock-unlock 과정이 짧은 경우에는 굳이 컨텍스트 스위칭으로 부하를 주는 것보다 Busy Waiting을 사용하는 방법이 효과적일 수 있습니다.
추가적으로 세마포어는 작성하기 힘들고 오류가 발생하기 쉬운데, 이 문제를 해결하기 위해 나온 것이 모니터입니다.

### 세마포어에 대해서 설명하시오.

- 세마포어는 세 개의 특수한 명령들만 접근할 수 있게 허용되는 보호된 변수입니다. 세 개의 명령은 초기화 명령, P(wait, down) 명령, V(signal, up) 명령이 있습니다. 

### 세마포어와 뮤택스의 차이를 설명하시오.

- 세마포어와 뮤택스는 여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법으로, 세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있는 반면에 뮤텍스는 오직 1개만의 프로세스(또는 쓰레드)만 접근할 수 있습니다. 그리고 세마포어의 경우에는 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.

### 모니터가 상호배제를 실현하는 방법에 대해 설명하시오.

- 모니터란 공유 데이터들과 이들에 대한 임계영역들을 관리하는 소프트웨어 구성체입니다. 모니터 내의 변수들은 프로시저들을 통해서만 접근이 가능한데, 모니터는 언제나 진입을 하나의 프로세스만으로 제한하기 때문에 이를 통해 상호배제를 자연스럽게 실현합니다.

### Race Condition은 주로 어느 영역에서 발생하는가?

- Race Condition은 커널 영역의 공유자원에 대한 경합으로 자주 발생하기 때문에 커널 영역에서 주로 발생한합니다.

### 교착 상태(Deadlock)에 대해 설명하시오.

- 교착상태란 자원이 한정적인 상황에서 두 개 이상의 프로세스가 각자 먼저 확보한 자원을 확보한 채 상대방의 자원을 필요로 하는 경우, 외부로부터의 조치가 없는 한 영원히 그 상태에서 대기하는 상황을 말합니다.

### 교착상태가 발생하기 위한 4가지 조건을 설명하시오.

- 자원의 배타적인 사용(모두가 공유 가능한 자원이 아니라는 뜻입니다), 자원의 부분 할당(프로세스는 필요한 자원을 한번에 확보하고 있는 게 아니라, 그때그때 필요한 자원들만 부분적으로 확보한다는 뜻입니다), 자원의 선점 불가능성(자원의 선점이 가능하면 그냥 뺏어오면 되니까 교착상태가 발생하지 않습니다), 자원에 대한 환형 대기(프로세스들이 각자 자신의 자원을 보유한 채 상대의 자원을 요구하여 대기 상태가 되는 걸 말합니다)입니다.

### 교착상태의 해결 기법 4가지를 설명하시오.

예방, 회피, 탐지, 복구 기법이 있습니다.
- 예방 기법은 교착상태가 발생하기 위한 4가지 조건 중 하나를 제거함으로써 예방하는 방법입니다.
- 회피 기법은 알고리즘을 사용하여 발생 조건을 회피하는 방법입니다.
- 탐지 기법은 예방이나 회피 기법과 달리 교착상태를 인정하고 이를 탐지하여 해결하는 방법입니다.
- 복구 기법은 교착 상태에 포함되어 있는 한 개 이상의 프로세스를 강제로 종료(혹은 선점)시킴으로써 이들로부터 반납되는 자원들을 나머지 프로세스들에게 제공하는 방법입니다.

### 교착 상태의 해결 방법 중 무시 기법에 대해 설명하시오.

- 무시 기법은 교착상태 자체를 무시하고, 특별한 조치를 취하지 않는 것을 말합니다. 만약 교착상태가 발생한다면, 프로세스를 종료하거나 자원을 선점하여 회복합니다. 교착상태의 발생 확률이 낮은 상황에서 효율적인데, 오늘 날의 컴퓨터에서는 교착 상태의 발생 확률이 낮기 때문에 UNIX, Windows 등 대부분의 운영체제가 이 방법을 사용한다고 알고있습니다.

### 안전 상태(Safe State)에 대해 설명하시오.

- 시스템에 있는 모든 프로세스가 유한 시간 내에 정상적으로 종료될 수 있는 상태를 안전 상태라고 합니다.

### 교착상태의 회피 기법 알고리즘 중 하나인 Banker's Algorithm에 대해 설명하시오.

- 안전 상태(Safe State)를 판단하는 방법은 현 상태에서 모든 프로세스가 정상적으로 종료할 수 있는 길이 적어도 하나 이상 존재하는가입니다. Banker's Algorithm은 불완전 상태를 유발할 수 있는 자원의 요구는 무시하고 기다렸다가 완전 상태를 유지할 수 있는 요구를 수용하여 시스템의 상태를 안전 상태로 계속 유지해 나가는 알고리즘입니다.

### 교착상태의 복구 기법의 두 가지 방식에 대해 설명하시오.

- 첫 번째는 "프로세스 종료 방식"입니다. 교착 상태를 형성한 프로세스들 중 몇 개를 강제로 종료시켜서 이들로부터 반납된 자원으로 복구를 하게 됩니다. 두 번째는 "자원 선점에 의한 방식"입니다. 이 방식은 필요한 자원을 가지고 있는 프로세스로부터 자원을 선점하여 교착 상태에 있는 프로세스들에게 할당하는 것을 의미합니다.

### 교착상태의 복구기법인 프로세스 종료 방식을 사용하면 어떤 방식으로 프로세스를 종료시켜야 하는가? 그리고 그 방식의 단점을 설명하시오.

- 첫 번째 방법은 종료 비용(Termination Cost)가 가장 작은 프로세스부터 하나씩 종료시켜 나가는 방법이며, 두 번째 방법은 교착 상태에 있는 프로세스들의 집합에서 가능한 모든 부분집합을 만들어서 이 집합에 속하는 프로세스들을 종료시켰을 경우의 종료비용을 따져 한꺼번에 종료시키는 방식이 있습니다.
첫 번째 방법은 프로세스를 하나 종료할 때마다 교착상태가 해소되었는지 확인해봐야하는 비효율성이 있으며, 두번째 방법은 최소 비용의 프로세스 집합을 고르기 위해서 모든 부분집합들의 종료 비용을 계산하기가 복잡하고 힘들다는 점입니다.

### 교착상태의 복구기법인 자원 선점에 의한 방식이 프로세스 종료방식과 어떤 차이점이 있는지 설명하시오.

- 두 방식 모두 프로세스를 종료시킨다는 점에서 같지만, 자원 선점에 의한 방식은 교착 상태에 빠진 프로세스들 중 종료시키는 것이 아니라 전혀 관련 없는 프로세스를 종료시킨다는 점에서 차이가 있습니다. 이 때, 강제 종료는 그 동안의 일을 없던 것으로 하고 처음부터 다시 시작해야하기 때문에 이런 낭비를 줄이기 위해 검사점을 지정하고 이를 재시작하여 잃게되는 일의 양을 최소화합니다.

### 고정(정적)분할과 가변(동적)분할에 대해 설명하시오.

- 고정 분할은 미리 메모리 분할을 해두고 고정적으로 운영하는 것을 말하며, 가변 분할은 프로세스의 크기나 개수에 따라 동적으로 운영하는 것을 말합니다.

### 메모리의 효율적인 구성을 위한 기법들에 대해 설명하시오.

- **적재 기법(Fetch Strategy)**은 언제 메모리를 할당해 줄 것인지에 따라 필요할 때마다 적재해주는 요구 적재와, 미리 적재해두는 예상 적재가 있습니다.
- **배치 기법(Placement Strategy)**는 프로세스들을 메모리의 어느 공간에 적재할 것인지를 말하며, 지정된 분할로만 적재할지, 아니면 분할을 달리하며 적재할지를 결정할 수 있습니다. 
- **교체 기법(Replacement Strategy)**은 메모리 공간이 부족할 경우 메모리에 있는 어느 프로세스를 디스크로 내보내서 공간을 확보시킬 것인지에 대한 기법입니다.
- **할당 기법(Allocation Strategy)**는 프로세스에게 메모리를 얼만큼 줄 것인지에 대한 내용입니다.

### 메모리의 크기보다 적재할 프로그램의 크기가 큰 경우에는 어떻게 해야하는가?

- 오버레이(Overlay)를 사용합니다. 오버레이는 프로그램의 일부분만을 먼저 적재하여 실행시킨 다음 나머지 부분들을 다시 적재하여 실행을 이어나가는 방식입니다.

### 고정 분할이 가지는 문제 중 "메모리 공간의 단편화"에 대해 설명하시오.

- 메모리 공간의 단편화란 이미 고정된 크기로 분할된 메모리 하에서 이에 딱 맞는 프로세스들로 채워지는 것은 불가능 하기 때문에, 이로써 발생되는 낭비를 의미합니다. 메모리가 프로세스를 수용하고 남는 공간으로써 발생하는 낭비는 "내부 단편화"라 하며, 아예 메모리 공간이 작아서 프로세스를 수용하지 못함으로써 발생하는 낭비는 "외부 단편화"(예시: 홀Hole)라 합니다.

### 가변 분할의 free 탐색 기법에 대해서 아는대로 설명하시오.

- **최초적합(First-fit)** 방법은 free list에 대해서 첫 노드에서부터 시작하여 제일 먼저 발견되는, 요구되는 크기보다 더 큰 빈 공간을 가지는 노드에 할당해주는 방법입니다. 장점으로는 리스트를 끝까지 순회하지 않기 때문에 다른 탐색 기법에 비해 효율적이며, 실행 속도가 빠른 것이 있습니다. 하지만 최초적합을 계속 사용하게되면 시간이 지날수록 리스트의 앞부분은 홀(hole)로 채워져서 탐색시간이 길어집니다. 하지만 이를 또 해결하는 방법으로는 리스트를 순환구조로 만들어주고 헤더포인터를 사용하는 방법입니다**(Next-fit)**.
- **최적적합(Best-fit)** 방법은 free list를 끝까지 탐색하여 요구되는 크기와 가장 딱 들어맞는 노드를 찾아 할당해주는 방법입니다. 단점으로는 최적적합의 결과로 남는 메모리의 크기는 너무 작아서 홀이 되어버린다는 것입니다.
- **최악적합(Worst-fit)** 방법은 free list를 끝까지 탐색해서 요구되는 크기보다는 크되, 그 차이가 제일 많이나는 노드를 찾아 할당해주는 방법입니다. 이 방법은 최적적합 방법의 단점을 극복하기 위한 것인데, 할당 후에도 남는 크기가 비교적 큰 공간이 되도록 하는 방법입니다.

### 가변 분할에서 홀(Hole)을 병합(compaction)하는 방법에 대해 설명하시오.

- 인접한 빈 공간을 병합하는 방식과, 모든 빈 공간을 통합하는 방식이 있습니다. 후자의 방식은 사용중인 메모리들을 한켠으로 다 옮겨 놓고 흩어져있던 빈 공간들을 병합하는 방식인데, 이를 사용하면 모든 프로세스들이 잠시 멈춰야 하며, 모든 프로세스들의 주소를 재배치 해야하므로 상당한 시간이 요구됩니다.

### 페이징(paging)에 대해 설명하시오.

- 페이징이란 프로세스들을 같은 크기의 조각들로 나누어 단편화를 해결하는 방법입니다. 단점으로는 내부단편화가 발생할 수 있다. ex) 10짜리를 4짜리 페이지로 - 4 4 2 ... 2만큼의 내부 단편화

### 페이징(paging)에서 논리(가상) 주소(페이지 번호 p, 페이지 내에서의 위치 d)를 바탕으로 물리(실) 주소를 찾는 과정을 설명하시오.

- 먼저 p를 토대로 페이지 테이블에서 프레임 번호(f)를 알아냅니다. 프레임 번호에서 시작 주소를 얻어낸 뒤 여기에 d를 더해서 실주소를 알아낼 수 있습니다.

### TLB에 대해 설명하시오.

- TLB란 고속캐시의 일종으로 주소로 접근하는 일반 메모리와 달리 키 값으로 접근하는 연관 메모리로서 검색이 빠릅니다. 이는 페이지 테이블을 메모리에 두고 접근할 때의 느림을 극복하기 위해 사용되며, 빈번하게 검색되는 엔트리들을 TLB에 넣되 페이지 번호(p)를 키 값도 표시합니다.

### 페이지 부재(page fault)란 무엇인지 설명하시오.

- 페이지의 부재란 참조한 페이지가 메모리에서 발견되지 않는 빈도를 말합니다. 페이지 부재가 높을 수록 해당 페이지를 메모리로 올리기 위한 커널의 개입을 통한 입출력이 요구되며, 해당 프로세스를 대기 상태(Blocked)로 만들어서 성능이 떨어지게 됩니다.

### 가상메모리의 적재 정책 중 요구 적재(Demand Fetch)에 대해 설명하시오.

- 페이지가 참조될 때 메모리에 적재하는 방법입니다. 이 방법은 참조하는 페이지들에 대해서만 메모리를 사용하게 되므로 오버헤드가 없으나, 페이지가 부재일 경우 해당 프로세스를 대기 상태로 만드는 문맥교환과 디스크와의 입출력 부담이 있게 됩니다. 다른 적재 정책으로는 예측 적재(Anticipatory Fetch)라는 게 있는데, 말 그대로 미리 예측하여 메모리에 적재하는 방법으로, 실험을 통해 요구 적재가 더 낫다는 게 판명되어서 거의 쓰이지 않습니다.

### 요구 적재의 장점에 대해 설명하시오.

- 필요한 페이지만 메모리에 올리기 때문에 프로세스를 올릴 수 있는 크기보다 더 많은 프로세스를 올릴 수 있습니다. 즉, 메모리 사용이 줄어듭니다.

### 가상 메모리의 배치 정책(Placement Strategy)에 대해 설명하고 페이징과 세그멘테이션에서는 어떻게 배치 정책을 사용하는지 설명하시오.

- 배치 정책이란 디스크로부터 받아온 페이지를 어디에 적재할 것인가에 대한 내용으로, 페이징의 경우 빈 프레임만 발견하면 어떤 프레임에 적재하든 문제가 없어서 배치 정책을 따로 신경 쓸 필요가 없습니다. 하지만 세그멘테이션을 사용하면 다양한 크기의 세그먼트를 수용할 수 있는 배치 정책이 요구되며, 최초 적합, 최적 적합, 최악 적합 등의 방법을 사용하게 됩니다.

### 가상 메모리의 교체 정책(Replacement Strategy) 알고리즘에 대해 아는대로 설명하시오.

- **최적 기법(Optimal, MIN)**은 현 시점에서 가장 오래도록 참조되지 않을 페이지를 교체하는 알고리즘입니다. 하지만 어떤 페이지가 미래에 가장 늦게 참조될 지 모르기 때문에 현실적으로 불가능한 방법이며, 다른 알고리즘의 성능을 비교해보는 잣대로 사용됩니다.
- **FIFO 기법**은 말 그대로 적재된 지 가장 오래된 페이지를 교체하는 알고리즘입니다. 두 가지 구현 방법이 있는데 첫 번째는 시간 기록(Time Stamping)을 통한 방법과, 큐를 사용하는 방법이 있습니다. FIFO 기법의 단점은 이후의 참조 가능성을 고려하지 않는다는 점입니다.
- **LRU(Least Recently Used) 기법**은 참조된지 가장 오래된 페이지가 교체 대상이 되는 알고리즘으로, FIFO 기법처럼 TIme Stamping과 Stack을 통한 두 가지 구현 방법이 있습니다. 스택을 통한 구현 방법은 스택의 가장 밑에 있는 페이지가 교체되며, 스택 내부의 페이지들 중 참조가 되는 페이지는 다시 스택의 최상단으로 올라갑니다.
- **Second-chance(Clock)** **기법**은 FIFO 방식에서 한 번이라도 참조된 페이지에 대해서는 메모리에 머무를 수 있는 기회를 한 번 더 주는 알고리즘입니다.
- **개선된** **Second-chance(NUR)** **기법**은 Clock 기법에 갱신 비트를 추가한 알고리즘입니다. 먼저, clock을 돌면서 먼저 참조 비트 = 0, 갱신 비트 = 0 인 페이지를 찾아서 교체합니다. 그리고 이 과정에서 포인터가 지난 페이지의 참조 비트는 0으로 바꿔줍니다. 만약 첫 번째 바퀴에서 교체할 페이지를 찾지 못했다면 다시 한바퀴 돌아봅니다. 아까 포인터가 지난 페이지에 대해 참조비트를 0으로 만들어 주었기 갱신 비트가 1이 아닌 페이지들이 교체됩니다.
- **LFU(Least Frequently Used)와 MFU(Most Fequently Used) 기법** 모두 적재되어 있는 동안의 참조 횟수를 누적하여 기록한 뒤 그 값을 바탕으로 교체 대상을 선택하는 알고리즘 방식입니다. LFU의 경우 많이 참조된 페이지는 앞으로도 참조될 확률이 높을 것이라 판단하는 방식이며, MFU의 경우 많이 참조된 페이지는 이제 충분히 참조가 이루어져서 더 이상 참조되지 않을 것이라 판단하는 방식입니다.

### LRU 기법과 LFU 기법의 차이점을 설명하시오.

- LRU 기법의 경우 최근의 참조 가능성을 바탕으로 하는 알고리즘이라면, LFU 기법의 경우 누적 참조 횟수를 고려하기 때문에 전체적인 참조 가능성을 바탕으로 하는 알고리즘이라는 차이가 있습니다.
**페이지 버퍼링(Page Buffering) 기법**은 단순한 교체 기법과 함께 사용되어 페이지의 성능을 향상 시킬 수 있는 장점을 갖습니다.

### 스레싱(Thrashing)에 대해서 설명하시오.

- 집중적으로 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못하면, 페이지 부재율(page fault rate)이 크게 상승해 디스크 I/O 작업이 발생하게되고, 이로인해 CPU 이용율이 급격히 떨어질 수 있는데, 이로인해 실제 CPU 사용 시간보다 페이지 교체에 시간이 더 많아질 수 있습니다. 이와 같은 현상을 스레싱이라고 합니다.

### Working set 이론에 대해 설명하시오.

- 프로세스가 특정 시점에서 집중적으로 참조하는 페이지들의 집합을 Working set이라고 하며, 이 Working set을 메모리에 적재함으로써 페이지의 부재를 최소화하겠다는 이론입니다.

### Working set 이론에서 윈도를 너무 크게잡거나 작게 잡으면 어떤 문제가 발생하는지 설명하시오.

- 너무 크게 잡으면 지역성에 포함되지 않는 페이지들도 Working set에 포함되어 메모리 낭비가 발생하며, 너무 작제 잡으면 지역성에 포함되는 페이지들조차 Working set에 빠져서 스레싱을 겪게됩니다.

### PFF에 대해 설명하시오.

- PFF는 Working set 이론의 윈도 크기를 결정하는 방법으로, 부재의 간격에 근거하여 결정하는 방법입니다. 부재의 간격이 크다는 것은 충분하거나 과도한 프레임이 주어졌다는 의미가 되며, 짧다는 것은 스레싱에 다가간다는 것으로 현재 할당된 프레임이 부족하다는 의미가 됩니다. 따라서 이에 따라 프레임을 줄여주거나 늘려주는 방식입니다.

### 캐시의 지역성 원리를 설명하시오.

- 캐시의 지역성은 프로세스들이 기억장치 내의 정보를 균일하게 액세스하는 것이 아니라 어느 순간에 특정부분을 집중적으로 참조하는 것을 말합니다. 지역성에는 시간적 지역성과 공간적 지역성이 있는데, 시간적 지역성은 한 번 참조된 주소의 내용은 곧 다음에 다시 참조된다는 특성으로 while이나 for와 같은 반복문을 예로 들 수 있으며, 공간적 지역성은 한 번 참조한 메모리의 옆에 있는 메모리를 다시 참조하게 된다는 특성으로, 배열을 예로 들 수 있습니다.\
