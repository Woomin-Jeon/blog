---
title: 2020-07-30 TIL
date: 2020-07-30
category: "All"
draft: true
---

## Facts

- 아침에 "그림으로 배우는 HTTP" p.33까지 복습했습니다.
- 부스트 캠프 챌린지에 참여하였습니다.

## Feelings

- 굵직굵직한 구현을 하는 것은 쉽습니다. 하지만 그것들에 대한 에러 처리와 예외 케이스 처리는 너무나도 고통스럽습니다.

## Findings

- **JavaScript의 Map 객체**
  - Map 객체는 Object와 달리 삽입순으로 순서가 보장됩니다.
  - Map 객체는 기본 size 속성으로 쉽게 길이를 얻을 수 있는데, Object는 기본으론 못하고 따로 함수를 만들어야 합니다.
  - Map 객체의 키는 Object와 달리 key로 어떤 타입이든 사용 가능한 반면, Object는 Symbol과 String만 가능합니다.
  - Map 객체는 iterable 프로토콜을 지원해서 바로 순회가 가능합니다.
- **Hash**
  - 해시 함수(Hash function)는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다.
  - 데이터의 길이가 랜덤해도 리턴값의 길이는 일정합니다.
  - 입력값이 같으면 리턴값도 언제나 동일합니다.
  - Hash를 생성하는 효율적인 방법은, 이미 누군가 만들어놓은 검증된 해쉬 함수 라이브러리를 가져다 쓰는 것이라고 생각합니다. (저는 crypto-js를 사용해봤는데 정말 편리했습니다.)
- **HashMap의 성능**
  - HashCode를 생성하는 Hash 함수의 성능이 고려되어야 하며,
  - 충돌이 발생했을 때 어떤 방식으로 처리할 지가 고려되어야 한다고 생각합니다. 충돌에 대한 처리는 여러가지 방법들이 있는데, 각각의 방법들 모두 장단점이 존재하며, 어느 것이 뛰어나다고 볼 수 없기 때문에 각자의 상황에 따라 적절한 방식을 사용해야한다고 생각합니다.
    - Separate Chaining (분리 연결법) : 각각의 해시 버킷을 링크드리스트로 만들어서 충돌이 발생하면 다음 노드로 이어주는 방식을 말합니다.
    - Open Address (개방 주소법) : 삽입하려는 해시 버킷이 이미 사용중이라면 다른 해시 버킷에 삽입하는 방식입니다. 이때 어떤 방식으로 다른 해시 버킷을 정할 것이냐에 따라 다시 3가지로 나뉩니다.
      - Linear Probing: 순차적으로 다음 인덱스를 탐색하며 비어있는 해시 버킷을 찾는 방식입니다.
      - Quadratic Probing: 2차 함수를 이용해 탐색할 위치를 찾는 것입니다.
      - Double Hashing Probing: 충돌이 발생하면 다른 해쉬함수를 재 적용해서 새로운 인덱스를 할당받는 것입니다.
- **단위 테스트에 대한 기준**
  - 제가 생각하는 단위 테스트의 기준은, 엄격하게는 각 함수가 하나의 역할만 하는 단위로 쪼개서 의존성을 최대한 줄이고 각각의 함수에 대해 테스트를 하는 것입니다. 하지만 코드를 모두 짠 뒤에 테스트를 붙이기에는 이미 싸놓은 똥 코드들이 서로 뒤얽혀서 제가 생각하는 단위 테스트의 기준에 부합시키기 힘들 것입니다. 각각의 의존성을 다시 없애줘야 하며, 여러개의 책임을 가진 함수들을 또 분리해야 하므로 너무나 고통스러운 작업입니다. 그렇기 때문에 아예 처음부터 TDD를 통해 작은 단위부터 테스트를 먼저 만들고 코드를 구현해 가는 것이 가장 확실하고 쉬운 테스트 방법이라고 생각합니다. 하지만 제 경험상 TDD를 통한 아주 작은 단위에서부터의 구현은, 어느 순간 정신차려보면 내가 전체 코드에서 어떤 부분에 대한 테스트를 짜고 있었던 것인지 저를 헷갈리게 합니다. 그렇기 때문에 그냥 무작정 TDD로 짜기 보다는 MarkDown과 같은 곳에 각각의 함수에 대한 설명과 이를 구현하기 위해 필요한 작은 함수들을 간단하게나마 메모해서 큰 숲을 그려 놓은 뒤에 이 숲을 계속 바라보면서 작은 단위에서부터의 TDD가 진행되어야 한다고 생각합니다.
- **ARP란?**
  - IP 통신은 MAC주소에 의존합니다. 보통 IP 통신은 여러 대의 컴퓨터와 네트워크 기기를 중계해서 목적지까지 도달하는데, 이 중계 기간 동안 다음으로 중계할 곳의 MAC주소를 사용하여 목적지를 찾아가게 됩니다. 이 때, 사용되는 것이 `ARP(Address Resolution Protocol`라는 프로토콜입니다. ARP는 주소를 해결하기 위한 프로토콜로, 수신지의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있습니다.
- **TCP에 대해서**
  - TCP는 대용량의 데이터를 보내기 쉽게 작게 분해(패킷으로 만든다는 뜻입니다)하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있습니다. 그리고 정확하게 도착했는지 확인하는 방법으로 Three way handshaking이라는 방법을 사용합니다. 만약 이 Three way handshaking 과정 중 통신이 도중 끊어지면 TCP는 그와 동시에 같은 수순으로 패킷을 재전송합니다. 참고로 Three way handshaking은 다음과 같은 수순을 거칩니다. SYN(패킷 보낸다?) - SYN/ACK(패킷 받았다!) - ACK(오키오키)
- **URI와 URL의 차이점**
  - URI는 Uniform Resource Identifier의 약자로, 리소스 식별자 입니다.  
    Uniform은 통일된 서식을 결정하는 것입니다. 이를 통해 여러가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급할 수 있게 합니다.  
    Resource는 "식별 가능한 모든 것"이라고 정의되어 있습니다.  
    Identifier은 식별 가느한 것을 참조하는 오브젝트이며 식별자로 불립니다.  
    결국, URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자입니다.  
  - URI는 리소스를 식별하기 위한 문자열 전반을 나타내는데 비해 URL은 리소스의 장소만을 나타냅니다. 그러므로 URI안에 URL이 포함되어 있다고 볼 수 있습니다. 아래는 URI와 URL의 예시입니다.  
  URI : [http://www.iana.org/assignment/uri-schemesa](http://www.iana.org/assignment/uri-schemesa)  
  URL : [http://www.iana.org](http://www.iana.org)

## Future Action Plans

- 조금 더 꼼꼼해질 필요가 있는 것 같습니다. 너무 덤벙대네요.

## Feedback

- 앞으로는 미션이 주어지면 꼼꼼하게 분석해서 요구사항을 분석해서 투두리스트처럼 만든 뒤 시작을 하는 게 좋을 것 같다.
