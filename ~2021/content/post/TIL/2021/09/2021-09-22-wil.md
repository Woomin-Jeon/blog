---
title: 2021-09-22 WIL
date: 2021-09-22
category: "All"
draft: true
---

## Facts

- 이번주는 큰 피쳐를 완성하고 배포해야하는 일정이 없어서 정말 정신없이 달렸던 것 같습니다. 야근의 연속... ㅋㅋ 그래도 열심히 한 결실인지 일정에 밀리지 않게 마무리 할 수 있어서 다행이었습니다. (비록 일정상 배포는 못했지만...)
- 회사에 계시는 동료분이랑 짝프로그래밍을 할 기회가 있었습니다. recoil async data query를 이용한 pagination에 대한 내용이었는데, 거의 3시간 반정도 동안 쉼없이 짝프를 했던 것 같습니다. 이 과정에서 많이 배울 수 있었고, 개발적인 이야기를 많이 나눌 수 있어서 재미있었습니다. 요즘 재택을 많이하다보니 집에서 혼자 개발하는 경우가 많고, 팀에 혼자 프론트엔드 개발자다보니 다른 동료분들과 프론트엔드적인 이야기를 많이 나눌 기회가 없었는데 짝프를 하니 되게 좋았습니다.
- 제가 이번주에 구현하고 있는 피쳐는 각 탭에 따라 피드를 그려주는 것인데, 피드의 특성상 스크롤을 내리는 만큼 DOM 엘리먼트가 쌓이게되고, 각 탭의 피드마다 이런 DOM 엘리먼트가 쌓이게 되다보니 탭간의 이동을 할 때 퍼포먼스가 저하되는 문제가 있었습니다. 일단 문제를 파악했을 때는 "dropped frames"가 많은 영향을 차지하고 있었는데, 동료분이 메모이징을 빡세가 해보라는 조언을 해주셨습니다. 제가 추측하기로는 화면 전환에 따라 기존에 사용되던 프레임들이 날라가고 새롭게 그리게되면서 발생하는 문제였던 것 같습니다. 결과적으로는 리액트 메모이징을 활용해서 불필요한 렌더링을 최대한 줄일 수 있도록 최적화를 했고, 많이 최적화 되어 어느정도 동작하는 걸 확인했습니다. 하지만 성능이 좋지 않은 디바이스에서는 여전히 버벅이는 문제가 있었고, 이를 해결하기 위해 각 탭에 있는 피드를 해당 탭이 활성화 되었을 때만 조건부 렌더링을 시켜주는 방법을 시도했습니다. 하지만 이렇게 하더라도 피드 자체가 무거워지게 되면 그 무거운 피드를 그리는데 소모되는 렌더링 시간 때문에 버벅이는 문제는 동일하게 발생했습니다. 결국 이를 해결할 수 있는 방법은 피드를 가볍게 하는 것이라고 생각했고, 뷰포트에 보이는 부분만 렌더링 할 수 있도록 하기 위해 Virtual Scrolling을 구현했습니다. 각 피드의 아이템들이 마운트될 때 height 값들을 구하고, 해당 뷰포트에 위치할 때만 그려주고 뷰포트를 벗어난 엘리먼트는 제거하도록 구현을 해서 결과적으로 피드가 가벼워 질 수 있었습니다. 이제 아무리 스크롤을 아래로 내리더라도 총 다섯개 정도의 아이템만 가지고 있을 수 있습니다. 처음 구현해본 Virtual Scrolling이고 구현하면서 약간 야매로 구현한 것 같은 느낌이 드는 부분이 조금 있어서 실제 프로덕트에 반영할 수 있을 지는 아직 모르겠지만 일단 해결하고 싶었던 문제는 결국 해결을 해낸 것 같아서 뿌듯합니다 ㅎㅎ 동료분께 리뷰를 부탁드렸는데 좋은 결과가 나와서 프로덕트에도 적용 가능했으면 좋겠네요!

## Feelings

- 이번 분기도 이제 끝나가네요. 저번 분기에 미쳐 못했던 부분들도 처리해야했고, 약간 숙제같은 느낌의 피쳐를 쳐내야하는 것도 있어서 이런 것들을 마치고나니 분기의 1/3이 사라졌었습니다. 그래서 정작 이번분기에 팀이 목표로 했던 것들은 많이 쳐내지 못한 것 같아서 마음이 무겁습니다. 다음 분기에는 더 잘 해낼 수 있었으면 좋겠네요.
- 원래는 리액트 메모이징을 이유 없이 사용하곤 하다가 지금은 불필요하게 퍼포먼스적인 문제가 발생하지 않는 이상 안쓰는 방향으로 가고 있었는데, 이번 기회에 근거있는 메모이징을 시도해볼 기회가 생겼고 실제로 퍼포먼스도 개선되는 모습을 보면서 너무 뿌듯했습니다. 좋은 경험을 한 것 같아요.
- 이번 추석 연휴에 원했던만큼 쉬었고, 하고 싶었던 공부도 할 수 있어서 좋았습니다. 잠도 정말 많이잤는데 ㅋㅋㅋㅋ 한 5일이니까 120시간 중에 50시간 정도는 자는데 쓰고 50시간은 놀고 20시간정도는 공부하는데 쓴 것 같습니다. 나름 알찬 연휴였던 것 같아요. 좋았습니다!

## Findings

- 성능적인 부분을 개선하기 위해 크롬 퍼포먼스 탭을 많이 구경할 일이 있었는데, 일단 많이 보다보니 조금은 친해진 것 같습니다.
- **모노레포**에 대해 간단하게 공부를 해봤습니다.
  - 왜 사용하는가?
      - 공통되는 기능들이 있는데 서로 다른 레포에 있어서 코드의 공유가 불가능한 경우에 이를 해결하는 방법은 다음과 같은 방법이 있을 것 같습니다.
          1. 그냥 코드를 복붙하거나
          2. npm 패키지로 공통되는 부분 모아서 배포하고, 이를 install 해서 사용하거나
          3. 모노레포로 만든다.
      - 1번 방법은 코드의 수정이 발생할 때 매번 수동으로 복붙해줘야 해서 유지보수에 있어서 좋지 않습니다.
      - 2번 방법은 괜찮은 방법이지만 공통 모듈이 변경될때마다 npm publish 다시 해주고, 사용하는쪽에서는 버전 올려서 다시 install 해줘야하는 번거로움이 있습니다.
      - 모노레포를 사용하면 이런 문제를 해결 할 수 있습니다. 공통으로 사용되는 패키지를 심볼릭 링크로 걸게되면 해당 패키지가 바뀌었을 때 이를 의존하는 다른 패키지에서도 바로 반영된걸 사용할 수 있습니다.
  - Lerna
      - Lerna는 모노레포를 구성할 때 도움을 주는 CI 툴입니다.
      - 주의할 점은 Lerna로도 패키지 의존성 관리를 할 순 있지만 할 때 이슈가 있으니까 이런 패키지 의존성관리는 잘하는 yarn에게 맡기는게 좋습니다.
      - 그래서 결국 Lerna로는 패키지들의 버전을 관리하고 배포하는 관리 역할을 맡기고, yarn으로는 각 패키지들의 의존성을 관리하는 역할을 맡겨서 역할을 분리시키는게 좋습니다.
      - 이렇게 Lerna + yarn 조합을 많이 사용한다고 합니다.
  - yarn workspaces를 이용한 의존성 설치 및 관리
      - 모노레포 내부에 있는 패키지를 yarn workspaces를 이용해서 설치하면 node_modules에 심볼릭 링크로 들어가게 됩니다. 그래서 원본이 바뀌면 바로바로 갱신되고, 사용할땐 이걸 그냥 가져다가 쓰기만 하면 됩니다.
      - 예를들어 모노레포 하위에 A, B라는 패키지가 있고, A에서 yarn workspaces를 해서 B를 설치하면, A의 node_modules에는 B의 심볼릭 링크가 들어가게 되는 구조입니다.
      - yarn workspaces말고 lerna로도 의존성 설치가 가능하긴 한데, 이 방면은 yarn이 잘하니까 yarn을 쓰는게 권장됩니다.(Lerna는 관련해서 뭔가 이슈가 많은 것 같습니다)
      - 참고로 npm은 모노레포 지원하지 않습니다.
  - 패키지 의존성 상속
      - 모노레포 내에서 관리하는 패키지 A에 B를 yarn workspaces로 설치한다고 해서 B 내부에 있는 의존성까지 같이 설치되는 건 아닙니다.
        - 이런 경우에는 B내부에 있는 모듈을 peerDependency로 관리해야 하나?
        - 아니면 모노레포 root에다가 설치를 해야하나?
  - 참고 자료
      - [심재철 미디엄 - \[MonoRepo\] lerna? yarn workspace? 크게 개념만 잡아보기](https://simsimjae.medium.com/monorepo-lerna-yarn-workspace-%ED%81%AC%EA%B2%8C-%EA%B0%9C%EB%85%90%EB%A7%8C-%EC%9E%A1%EC%95%84%EB%B3%B4%EA%B8%B0-c58bc4ba31fe)
      - [기억보단 기록을 - Lerna와 yarn-workspace를 활용한 Mono Repo (Typescript & Jest) 환경 구성하기](https://jojoldu.tistory.com/585)
      - [Workspaces | Yarn](https://classic.yarnpkg.com/en/docs/workspaces/)


## Future Action Plans

- 개발 일정을 말씀드릴 때 보통 제가 생각하는 것의 1.5배 정도로 말씀드리면 대충 일정이 맞았던 것 같습니다. 그런데 이렇게 일정을 말씀드릴때는 근무하는 모든 시간을 개발에 투입했을 경우를 기준으로 말씀드리는 건데, 일을 해보니 항상 이런 근무 외에 추가적으로 들어오는 일정이 끼게 돼서 생각보다 일이 미뤄지는 경향이 있는 것 같다고 느꼈습니다. 앞으로는 일정을 고려할 때, 이를 하면서 생길 수 있는 변수도 같이 담아서 고려할 수 있도록 해야겠습니다.

## Feedback
