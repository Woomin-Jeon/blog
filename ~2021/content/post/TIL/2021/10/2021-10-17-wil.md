---
title: 2021-10-17 WIL
date: 2021-10-17
category: "All"
draft: true
---

## Facts

- 이번주는 Google Analytics와 함께 한 주를 보낸 것 같습니다. UA 버전으로는 회사 동료분이 잘 정리해두신 것과 베이스 코드가 있어서 쉽게 적용할 수 있었는데, GTM은 아직 저희 프로젝트에서 기술상의 한계가 있어서 삽질만 하다가 적용은 포기했습니다. 그래고 이 과정에서 UA와 GA4, GTM까지 개략적은 개념과 내용은 알 수 있었던 것 같아서 너무 유익했습니다.
- ORK이 잘 마무리 되었습니다. 이번 분기 ORK은 지금까지 해왔던 OKR보다 더 뾰족하고, 목표가 분명한 것 같아서 좋은 성과를 내볼 수 있을 것 같다는 좋은 느낌이 듭니다. 이번 분기 화이팅!
- `VirtualScrollRenderer` 구현이 장장 50개의 리뷰끝에 완료되어 프로덕션 적용을 하였습니다(감격). 센트리를 통해 잘 동작하는지 어느정도 트래킹하고 있는데 제가 생각하는 범위 내에서는 큰 문제는 발생하지 않고 있는 것 같습니다. 다음주쯤에 조금 더 다듬어 패키지로 만든 다음 npm으로 배포도 한번 해볼까 합니다.
- 리뷰를 받으면서 useEffect의 동작 순서에 대한 고민을 다시금 해볼 수 있었습니다. 사실 지금까지는 "개념"적으로만 `useEffect`는 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount와` 같이 동작하므로 컴포넌트가 "마운트"될 때, "업데이트" 될 때, "언마운트" 될 때 호출된다고만 알고 있었고, 실제 구현할 때는 이 개념을 이용해서 크게 동작순서를 고려할 일은 없었습니다. 하지만 실제 동작 순서를 고려해야하는 케이스르 겪으면서 이 개념을 구체화할 수 있었던 것 같아 좋았습니다.
- 센트리 정리를 했습니다. 현재 프로젝트에서 불필요하게 센트리로 쏘고 있거나, 노운 에러이지만 핸들링하지 않고 있어서 지속적으로 센트리로 쏴지고있는 것들이 있었습니다. 이로 인해 저희 프로젝트에서 너무 많은 에러를 쏘고 있었고 결국 회사의 비용부담이 커지고 있는 문제가 있었습니다. 그래서 동료분과 함께 하나하나 에러를 정리하는 시간을 가졌고 나름 깔끔해진 것 같아 뿌듯합니다! (막 그렇게 손이 가는 작업은 아니었는데 동료분과 같이 정리하니까 너무 재미있게 금방 끝낼 수 있었습니다 😄)
- 이번주 수요일에는 회사 동료분의 결혼기념 회식을 진행했습니다 ㅎㅎㅎㅎ 축하드려요 닐! 살면서 청첩장도 처음받아봤는데 너무 신기했습니다.
- changeset을 사용할 일이 있었는데, 제대로 된 이해도 없이 시도한 결과 큰 똥을 만들었고 결국 다른 동료분이 치워주셨습니다... ㅠㅠ 아 이러면 안되는데 스스로가 조금 한심스러웠습니다 ㅠ

## Feelings

- 뭔가 이번주는 이것저것 많이 시도해볼 수 있었고 기술적인 고민도 많이 해볼 수 있었어서 자질구레하게 많이 배운 한 주인 것 같습니다. 뿌듯합니다.
- 회사에 자주 출근하니 의욕도 다시 생기고 일하는 것도 재밌고 너무 좋은 것 같습니다.

## Findings

- `intersectionObserver` vs `scrollEvent`  
  - 스크롤 이벤트를 이용하게 되면 배 스크롤 이벤트마다 콜백을 호출하게 되고 이로인해 너무 많은 동기적인 함수를 호출하게 되어 메인쓰레드를 막고 퍼포먼스를 저하시킬 위험이 있습니다. 하지만 인터섹션옵저버는 비동기적으로 동작하기 때문에 메인쓰레드를 블로킹하지 않고 결과적으로 퍼포먼스가 좋아집니다.
  - 스크롤 이벤트를 이용하면 뷰포트에 해당 내용이 존재하는지와 같은 걸 확인 할 때 엘리먼트의 offset과 같은 정보가 필요하게 됩니다. 이렇게 레이아웃을 계산하는 과정에서 리플로우가 발생하게 되는데, 인터섹션옵저버는 리플로우가 발생하지 않습니다.
  - 이렇듯 인터섹션옵저버는 성능상에 장점이 존재하고, 사용이 편리하다는 장점이 있지만 스크롤 이벤트처럼 유연하게 사용하긴 힘들다는 단점이 있습니다. (당연한거지만...)

- `useEffect` 동작 순서  
  다음 코드에서 콘솔은 어떻게 출력될까요?

  ```tsx
  const Parent = () => {
      useEffect(() => {
        console.log('parent useEffect')
      }, [])

      console.log('parent call')

      return <Child />
  }

  const Child = () => {
      useEffect(() => {
        console.log('child useEffect')
      }, [])

      console.log('child call')

      return <div>Hello</div>
  }
  ```

  콘솔은 다음과 같이 출력됩니다.

  ```
  parent call 
  child call 
  child useEffect 
  parent useEffect 
  ```

  위 컴포넌트의 실행 흐름은 다음과 같습니다.

  - Parent 컴포넌트 실행
  - Parent.useEffect 등록
  - **console.log('parent call') 실행**
  - Child 컴포넌트 실행
  - Child.useEffect 등록
  - **console.log('child call') 실행**
  - (자식부터 컴포넌트가 마운트되기 시작)
  - Child 컴포넌트 마운트
  - Child.useEffect 실행
  - **console.log('child useEffect') 실행**
  - Parent 컴포넌트 마운트
  - Parent.useEffect 실행
  - **console.log('parent useEffect') 실행**

- `UA` vs `GA4` vs `GTM`
  - 예전에는 UA(Universal Analytics)만 있었고 이를 통해 구글애널리틱스 이벤트를 심고 확인할 수 있었습니다.
  - 이후 더 발전시켜서 나온 애널리틱스가 GA4(Google Analytics 4)이며, 웹+모바일의 이벤트도 처리할 수 있게된 발전된 형태입니다.
  - 이런 UA와 GA4는 모두 개발자가 적재적소에 이벤트를 하드코딩으로 심어줘야합니다. 이런 방식은 개발자 의존적이게되고, 프로덕트 코드에 지저분하게 이벤트관련 코드가 삽입된다는 단점이 있습니다. 이런 문제를 해결할 수 있는 것이 GTM(Google Tag Manager)입니다. GTM을 이용하면 GTM을 세팅하는 스크립트 하나만 로드해 놓고 GTM 홈페이지에서 GUI로 이벤트를 심을 수 있습니다. GTM으로 이벤트를 심을 때는 크게 세 가지가 필요한데, "태그", "트리거", "변수" 입니다. "태그"는 심은 이벤트를 어떻게 처리할지를 정하는 것이고, "트리거"는 어떤 상황에서 이벤트를 발생시킬지를 정하는 것입니다. "변수"는 말 그대로 각 상황에서 필요한 변수들을 정의하는 것입니다. 이렇게 "태그", "트리거", "변수"를 이용해서 다음과 같은 이벤트를 발생시킬 수 있습니다. "/home으로 시작하는 path(변수)"에 대해, "페이지 이동시(트리거)"마다 이벤트를 발생시키는데, 이 이벤트를 "GA4(태그)"로 쏜다.

## Future Action Plans

- 점점 주말에 게을러지고 있는 것 같습니다. 경계해야겠습니다.
- 뇌를 쓰면서 코드를 짜는 습관을 계속 유지할 수 있도록 해야겠습니다. 단 한줄의 코드에도 의미를 담을 수 있도록 계속 신경쓰겠습니다.

## Feedback
