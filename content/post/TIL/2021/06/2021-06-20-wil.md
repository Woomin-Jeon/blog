---
title: 2021-06-20 WIL
date: 2021-06-20
tag: [TIL]
---

## Facts

- 특정 컴포넌트의 너무 다양한 관심으로 인해 (매니저+사업, 뷰어+사업, 매니저+유저, 뷰어+유저, 프리뷰+사업, 프리뷰+유저) 분기처리를 하는 것이 복잡해지는 문제가 있어서 이를 각각의 컴포넌트로 분리하는 리팩터링 작업을 해봤습니다. 일단 각 케이스의 관심사에 맞게 분리하긴 해서 앞으로 편하게 작업할 순 있을 것 같은데 중복이 많이 발생해서 잘 한건지는 모르겠습니다. 항상 관심사에 맞게 나누면 중복이 발생하는... 딜레마가 존재하는 것 같습니다. 그렇다고 중복되는 함수들을 추출해서 또 엮자니 결국 두 컴포넌트에 의존성이 생기고... 어렵네요
- 이런 리팩터링을 하다가 발생한 버그가 있었습니다. 하나의 파일에 있던 것들을 여러 파일로 분리하는 과정에서 다른 케이스이지만 같은 이벤트 함수가 들어가버렸고, 이로인해 에러가 발생했습니다. 이때 해당 이슈를 해결하는데 약 1시간 30분간의 시간이 소요됐는데 이에 대해 회고해보았습니다.
  - 시간이 오래 걸린 이유
      - 분명 기존에 발생하지 않다가 배포로 인해 발생한 문제라면, 내가 짠 코드 중에 문제를 발생시킨 애가 있다는 의미인데 이를 너무 늦게 깨달음.
      - 쓸 데 없이 다른 파일을 보며(인증 관련 에러여서 손대지 않은 인증 쪽을 계속 살펴봄) "인증쪽 바뀐 로직이 없는데... 왜이러지...?"라고 생각 하면서 시간이 많이 지체됨
  - 앞으로
      - 내가 짠 코드에서 차근차근 문제를 찾아야 함
      - 배포 PR의 크기가 너무 크니까 변경된 파일을 살펴보기가 힘듦. 배포 PR을 작게작게 유지하면서 작지만 자주 배포하도록 해야겠음
- 이번주에는 팀회식을 하는 자리가 있었습니다.

## Feelings

- 이번주는 리팩터링 작업을 하고 이로인해 발생한 버그를 잡는데 시간을 소요해서인지 아웃풋이 많이 없는 것 같아서 아쉽습니다.

## Findings

- 케이스에 대한 타입처리는 다음과 같이 가능합니다. 예를들어, event가 true면 onClick도 받고, event가 false면 onClick을 받지 않고 싶을때, 즉, event의 값과 onClick이 같이 가는 속성인 경우 다음과 같은 처리가 가능합니다.

  ```ts
  type Props = ({
      event: true
      onClick: () => void
  } | {
     event: false
  })
  ```

- 미리보기 화면을 만들 때, 이를 감싸는 엘리먼트 하나에다가 onClick 이벤트를 걸어주고 여기에 preventDefault와 stopPropagation을 걸어줌으로써 쉽게 이벤트를 막을 수 있습니다. 이때, capturing을 사용하면 좋습니다.

  ```jsx
  const Preview = () => {
      const ref = useRef(null)
      
      useEffect(() => {
        const handleBlockClickEvent = (e) => {
          e.preventDefault()
          e.stopPropagation()
        }

        ref.current.addEventListener('click', handleBlockClickEvent, { capture: true })
        return () => ref.current.removeEventListener('click', handleBlockClickEvent, { capture: true })
      }, [])

      return <div ref={ref}>...</div>
  }  
  ```

- HOC(고차 컴포넌트)는 컴포넌트를 재사용하기 위한 패턴으로, 컴포넌트를 받아와서 새로운 컴포넌트를 반환하는 함수입니다.  
  이때 주의할 점은, 함수형 컴포넌트 내부에서 고차 컴포넌트를 사용하면 리렌더링마다 새로운 함수가 반환되기 때문에 컴포넌트가 다시 마운트되면서 기존의 컴포넌트가 갖던 서브트리를 버리고 새롭게 서브트리를 생성하는 비효율성이 발생하게됩니다. 마찬가치로 state 역시 손실됩니다.

- **React의 key에 대해서**  
  React는 변경이 감지되면 DOM의 노드들을 순회하면서 어느 부분이 바뀌었는지를 탐색합니다. 이때 일반적인 탐색 알고리즘으로는 n개의 트리에 대해 O(n^3)의 복잡도를 갖게되는데 이는 너무나도 큰 시간복잡도입니다. 따라서 React는 서로 다른 타입의 엘리먼트라면 새로 트리를 만들고, 리스트에는 key을 사용하여 복잡도를 O(n)까지 줄였습니다. 이렇듯 React에서 key가 하는 역할은 Reconciliation 비용을 줄여주는 것입니다. 이때 key는 변하지 않는 고유한 값을 사용해야 하는데, Math.random()과 같은 결과를 key값으로 사용하게될 경우 매번 key가 다르기 때문에 새롭게 DOM 트리를 생성해서 성능이 안좋아질 수 있습니다. 아울러 key를 명시하지 않으면 자동으로 배열의 index를 key로 사용하는데, 이 경우 배열의 순서가 바뀌게되면 원치 않는 동작이 나타날 수 있습니다.

- 모노레포란 여러개의 프로젝트를 하나의 레포지토리에서 관리하는 걸 말합니다. 이렇게 함으로써 여러 프로젝트에서 중복되는 코드들을 줄일 수 있고(lint 설정 등), 여러 프로젝트에 걸친 수정이 용이하다고 합니다.

- useOpaqueIdentifier (React 18) - id 생성기

- HTML `<section>` 요소에 대해서 (MDN)  
  - 각각의 `<section>`을 식별할 수단이 필요합니다. 주로 제목(`<h1>`~`<h6>`) 요소를 `<section>`의 자식으로 포함하는 방법을 사용합니다.
  - 요소의 콘텐츠를 따로 구분해야 할 필요가 있으면 `<article>` 요소를 고려합니다.
  - `<section>` 요소를 일반 컨테이너로 사용하지 않습니다. 특히 단순한 스타일링이 목적이라면 `<div>` 요소를 사용해야 합니다. 대개, 문서 요약에 해당 구획이 논리적으로 나타나야 하면 `<section>`이 좋은 선택입니다.

- Chevron관련해서 열고 닫을 때 요런 CSS 를 사용하면 하나의 SVG로도 이쁜 애니메이션으로 만들 수 있습니다!

    ```tsx
    transition: transform 200ms;
    transform: scaleY(${({ open }) => (open ? -1 : 1)});
    ```

## Future Action Plans

- TIL Feedback을 안하고 있습니다. 얼른 해야하는데 자꾸 미뤄지네요 ㅠ
- 위에도 써놓은 내용이지만 다시 적습니다. 앞으로 배포 이후 이슈가 발생했을 때는, 그리고 빠르게 대처하기 위해서는,
  - 내가 짠 코드에서 차근차근 문제를 찾는다.
  - 배포 PR을 작게작게 유지하면서 작지만 자주 배포하도록 한다.

## Feedback
