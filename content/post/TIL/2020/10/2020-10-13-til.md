---
title: 2020-10-13 TIL
date: 2020-10-13
tag: [TIL]
---

## Facts

- 아침에는 옵저버 패턴에 대한 고민을 하였습니다.
- 부스트 캠프 멤버십에 참여하였습니다.
- CS 스터디에 앞서 해당 내용을 공부 하였습니다.
- CS 스터디에 참여하였습니다.

## Feelings

- 시간이 없네요. 얼마나 더 부지런히 살아야 하는지

## Findings

- **Webpack Alias**  
  웹팩 얼라이어스를 사용하면 import 시 복잡한 path를 간결하게 할 수 있습니다.

    ```js
    module.exports = {
      ...
      resolve: {
        alias: {
          '@': path.resolve(__dirname, './src/'),
          '@login': path.resolve(__dirname, './src/components/login/'),
          '@header': path.resolve(__dirname, './src/components/header/'),
          '@breakdown': path.resolve(__dirname, './src/components/breakdown/'),
        },
      },
      ...
    };
    ```

    ```js
    import BreakdownForm from '../../src/components/breakdown/BreakdownForm.js';
    import BreakdownForm from '@breakdown/BreakdownForm.js';
    ```

- **고정(정적)분할과 가변(동적)분할에 대해 설명하시오.**  
  고정 분할은 미리 메모리 분할을 해두고 고정적으로 운영하는 것을 말하며, 가변 분할은 프로세스의 크기나 개수에 따라 동적으로 운영하는 것을 말합니다.
- **메모리의 효율적인 구성을 위한 기법들에 대해 설명하시오.**  
  - **적재 기법(Fetch Strategy)**은 언제 메모리를 할당해 줄 것인지에 따라 필요할 때마다 적재해주는 요구 적재와, 미리 적재해두는 예상 적재가 있습니다.
  - **배치 기법(Placement Strategy)**는 프로세스들을 메모리의 어느 공간에 적재할 것인지를 말하며, 지정된 분할로만 적재할지, 아니면 분할을 달리하며 적재할지를 결정할 수 있습니다. 
  - **교체 기법(Replacement Strategy)**은 메모리 공간이 부족할 경우 메모리에 있는 어느 프로세스를 디스크로 내보내서 공간을 확보시킬 것인지에 대한 기법입니다.
  - **할당 기법(Allocation Strategy)**는 프로세스에게 메모리를 얼만큼 줄 것인지에 대한 내용입니다.
- **메모리의 크기보다 적재할 프로그램의 크기가 큰 경우에는 어떻게 해야하는가?**  
  오버레이(Overlay)를 사용합니다. 오버레이는 프로그램의 일부분만을 먼저 적재하여 실행시킨 다음 나머지 부분들을 다시 적재하여 실행을 이어나가는 방식입니다.
- **고정 분할이 가지는 문제 중 "메모리 공간의 단편화"에 대해 설명하시오.**  
  메모리 공간의 단편화란 이미 고정된 크기로 분할된 메모리 하에서 이에 딱 맞는 프로세스들로 채워지는 것은 불가능 하기 때문에, 이로써 발생되는 낭비를 의미합니다. 메모리가 프로세스를 수용하고 남는 공간으로써 발생하는 낭비는 "내부 단편화"라 하며, 아예 메모리 공간이 작아서 프로세스를 수용하지 못함으로써 발생하는 낭비는 "외부 단편화"(예시: 홀Hole)라 합니다.
- **가변 분할의 free 탐색 기법에 대해서 아는대로 설명하시오.**  
  - **최초적합(First-fit)** 방법은 free list에 대해서 첫 노드에서부터 시작하여 제일 먼저 발견되는, 요구되는 크기보다 더 큰 빈 공간을 가지는 노드에 할당해주는 방법입니다. 장점으로는 리스트를 끝까지 순회하지 않기 때문에 다른 탐색 기법에 비해 효율적이며, 실행 속도가 빠른 것이 있습니다. 하지만 최초적합을 계속 사용하게되면 시간이 지날수록 리스트의 앞부분은 홀(hole)로 채워져서 탐색시간이 길어집니다. 하지만 이를 또 해결하는 방법으로는 리스트를 순환구조로 만들어주고 헤더포인터를 사용하는 방법입니다**(Next-fit)**.
  - **최적적합(Best-fit)** 방법은 free list를 끝까지 탐색하여 요구되는 크기와 가장 딱 들어맞는 노드를 찾아 할당해주는 방법입니다. 단점으로는 최적적합의 결과로 남는 메모리의 크기는 너무 작아서 홀이 되어버린다는 것입니다.
  - **최악적합(Worst-fit)** 방법은 free list를 끝까지 탐색해서 요구되는 크기보다는 크되, 그 차이가 제일 많이나는 노드를 찾아 할당해주는 방법입니다. 이 방법은 최적적합 방법의 단점을 극복하기 위한 것인데, 할당 후에도 남는 크기가 비교적 큰 공간이 되도록 하는 방법입니다.
- **가변 분할에서 홀(Hole)을 병합(compaction)하는 방법에 대해 설명하시오.**  
  인접한 빈 공간을 병합하는 방식과, 모든 빈 공간을 통합하는 방식이 있습니다. 후자의 방식은 사용중인 메모리들을 한켠으로 다 옮겨 놓고 흩어져있던 빈 공간들을 병합하는 방식인데, 이를 사용하면 모든 프로세스들이 잠시 멈춰야 하며, 모든 프로세스들의 주소를 재배치 해야하므로 상당한 시간이 요구됩니다.
- **버디 시스템에 대해 설명하시오.**  
  버디 시스템은 고정 분할과 가변 분할을 타협한 절충안입니다. 프로세스의 적재 요구에 대해 메모리를 2의 승수로 분할해주고 버디를 만들어줍니다. 버디는 자신의 버디가 비게 되면 병합됩니다.
- **페이징(paging)에 대해 설명하시오.**  
  페이징이란 프로세스들을 같은 크기의 조각들로 나누어 단편화를 해결하는 방법입니다. 단점으로는 내부단편화가 발생할 수 있다. ex) 10짜리를 4짜리 페이지로 ⇒ 4 4 2 ... 2만큼의 내부 단편화
- **페이징(paging)에서 가상주소(페이지 번호 p, 페이지 내에서의 위치 d)를 바탕으로 실 주소를 찾는 과정을 설명하시오.**
  먼저 p를 토대로 페이지 테이블에서 프레임 번호(f)를 알아냅니다. 프레임 번호에서 시작 주소를 얻어낸 뒤 여기에 d를 더해서 실주소를 알아낼 수 있습니다.
- **TLB에 대해 설명하시오.**  
  TLB란 고속캐시의 일종으로 주소로 접근하는 일반 메모리와 달리 키 값으로 접근하는 연관 메모리로서 검색이 빠릅니다. 이는 페이지 테이블을 메모리에 두고 접근할 때의 느림을 극복하기 위해 사용되며, 빈번하게 검색되는 엔트리들을 TLB에 넣되 페이지 번호(p)를 키 값도 표시합니다.

## Future Action Plans

- 같이 공부하시는 분들 보니 정말 열심히 하시는 것 같아 분발해야겠습니다.

## Feedback
