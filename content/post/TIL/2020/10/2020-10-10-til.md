---
title: 2020-10-10 TIL
date: 2020-10-10
tag: [TIL]
---

## Facts

- 어제 진행했던 CS 스터디의 내용을 가볍게 복습했습니다.
- "하루 3분 네트워크 교실"을 읽으면서 OSI 7 레이어의 흐름을 따라가보고 브라우저에서 naver.com을 입력했을 때 어떤식으로 동작하는지를 공부해보았습니다.
- "그림으로 배우는 HTTP"를 읽고 HTTP에 대해 가볍게 복습하였습니다.
- "웹을 지탱하는 기술"을 읽고 REST에 대해 공부하였습니다.
- "코어 자바스크립트"를 읽고 까먹은 부분에 대해 복습하였습니다.

## Feelings

- 아 오늘 하루종일 책만 읽었더니 빡세네요...

## Findings

- **PUT과 PATCH의 차이**  
  PATCH는 데이터의 수정에 있어서 해당되는 부분만 전송하면 되지만 PUT은 모든 부분을 전송해야한다고 합니다. 그래서 데이터의 부분만 수정할 때는 PATCH를, 데이터의 전부를 수정할 때는 PUT을 사용하는 게 올바르다고 합니다.
- **PUT을 이용한 리소스 생성과 POST를 이용한 리소스 생성의 차이**  
  PUT은 보통 수정(update)에 사용하지만 PUT으로 리소스를 작성할 수도 있는데, POST와의 차이점은 다음과 같습니다. POST로 리소스를 작성하면 클라이언트에서는 리소스의 URI를 직접 지정할 수 없습니다. 하지만 PUT을 사용하여 리소스를 작성할 경우, 리소스의 URL는 클라이언트가 결정할 수 있게됩니다. 예를 들어 Twitter와 같이 포스팅한 트윗의 URI를 서버 측이 자동으로 결정하는 웹사이트는 POST가 적합하지만, Wiki처럼 클라이언트가 결정한 타이틀이 그대로 URI가 되는 웹서비스의 경우는 PUT을 쓰는 것이 적합합니다.  
  일반적으로는 POST를 이용하여 URI를 서버측에서 결정하는 서비스가 바람직합니다.
- **멱등성과 안전성**  
  멱등성이란 어떤 조작을 몇 번을 반복해도 결과가 동일한 것을 의미하며,  
  안전성이란 조작 대상의 리소스의 상태를 변화시키지 않는 것을 의미합니다.  
  GET과 HEAD 메서드는 멱등하면서 안전합니다.  
  PUT과 DELETE 메서드는 멱등하지만 안전하지 않습니다.  
  POST 메서드는 멱등하지도 안전하지도 않습니다.
- **브라우저에 URL을 입력하고 엔터를 치면 발생하는 일들**  
  1. 브라우저가 URL을 파싱한다.
  2. DNS(Domain Name Server)를 조회하여 수신처의 IP를 얻는다.
  3. 수신처의 IP를 통해 ARP 요청을 함으로써 수신처의 MAC 주소를 얻는다.
  4. 대상과 TCP 통신을 통해 Socket을 연다.
  5. HTTPS인 경우 TLS(Transport Layer Security) handshake가 추가된다.\
  6. HTTP 프로토콜로 요청(Request)한다.
  7. HTTP 서버가 응답(Response)한다.
  8. 웹 브라우저가 그린다.
- **OSI 7 레이어**  
  예전(1960 ~1970)에는 각 업체가 통신에 사용하는 기기 및 프로토콜을 각자 자신의 규격으로 만들었습니다. 그렇다보니 다른 업체와 규격이 달라서 호환되지 않는 경우가 많았습니다. 이러한 문제점을 해결하기 위해 ISO의 표준화 단체에서 선언한 것이 OSI 7 레이어 입니다.  
  OSI 7 레이어는 데이터 통신을 7단계로 나누어서 각 단계의 순서를 명확히하고, 이 모델에 따라 프로토콜을 정의해서 데이터 통신을 구축한 것입니다.
  - **[제 7계층] 응용 계층**
    - 7계층은 가장 최 상위의 계층으로, **애플리케이션의 목적에 따라 네트워크 서비스를 제공**하는 계층이다. 즉, 애플리케이션의 목적에 따라 홈페이지 열람이라면 HTTP를 준비하던지, 파일전송이라면 FTP를 준비하던지, 이메일이라면 SMTP를 준비하던지와 같은 활동을 여기서 한다.
  - **[제 6계층] 표현 계층**
    - 6계층은 표현 계층으로, **데이터의 형식을 변환하여 하드웨어랑 OS에 따른 차이를 없애는 계층**이다.  
      예를 들어, 송신측 6계층에서 ASCII를 네트워크 전송용 코드로 변환하고, 수신측 6계층에서 네트워크 전송용 코드를 EBCDIC으로 변환하는 것이 있다.
    - **압축**이나 **암호화**도 한다.
  - **[제 5계층] 세션 계층**
    - 5계층은 세션계층으로, **애플리케이션 간의 대화**를 하는 계층이다.
    - 참고  
      TCP / IP 모델에서의 5 ~ 7 계층은 하나로 묶이며, HTTP의 경우 5 ~ 7 계층 모두의 일을 한다.
  - **[제 4계층] 전송 계층**
    - 3계층 까지는 송수신한 데이터에 대해 뭐 망가지든 파기되든 손실되든 신경쓰지 않는다. 이에 대한 **에러복구를 하는 것이 바로 4계층**이다.
    - TCP는 데이터 통신 이전에 안전하게 통신할 수 있다고 판단되는 가상의 통신로를 확보하는데 이를 위한 방법이 **커넥션의 확립**이다.
    - 그리고 이 커넥션의 확립은 3-way-handshake를 통해 이루어진다. 커넥션의 종료는 4-way-handshake를 통해 이루어진다.
    - **3-way-handshake**
      송신측** : SYN (통신 고?)  
      수신측 : ACK (오키) SYN (통신 고!)  
      송신측 : ACK (오키)  
    - **4-way-handshake**
      송신측 : FIN (종료 고) ACK (오키?)  
      수신측 : ACK (오키)  
      수신측 : FIN (종료 고) ACK (오키?)  
      송신측 : ACK (오키)
    - **UDP는 보내면 끝**
  - **[제 3계층] 네트워크 계층**
    - 2계층이 세그먼트 내에서의 통신이었다면, **3계층은 세그먼트 "간"의 데이터 통신**을 의미한다.
    - 3계층에서는 **어드레싱**을 통해 수신처의 주소를 특정하고, **라우팅**을 통해 수신처까지 어떤 경로로 갈 지를 결정한다.  
      이렇게 어드레싱과 라우팅을 이용해 인터넷 작업을 수행하기 위한 프로토콜이 **IP(Internet Protocol)**이다.
    - 클래스풀 어드레싱, 서브네팅, 클래스리스 어드레싱
    - **DHCP는 IP주소를 할당받기 위한 프로토콜**로, IP 주소를 관리하고, 실제로 할당 작업을 수행하는 서버와, 할당을 받는 클라이언트로 이루어진다.
    - **ARP란 주소 해결 프로토콜**로 수신처 IP가 정해지고나서 ARP를 통해 MAC 주소를 알아낸다. 먼저, ARP 테이블을 사용해서 알아내고, 만약 ARP 테이블에 해당 IP에 대응되는 MAC 주소가 없다면 브로드 캐스트를 통해 알아낸다.  
    이때, 브로드캐스트를 사용하면 라우터 범위를 넘어설 수 없는데 이는 어떻게 하는걸까? 보통 수신처는 다른 네트워크에 존재하는데?  
    바로 디폴트 게이트웨이(사실상 첫번째 라우터)의 IP를 사용하여(DHCP로부터 IP를 할당받을 때 디폴트 게이트웨이의 IP도 같이 저장됨) ARP를 보내서 디폴트 게이트웨이의 MAC 주소를 얻고 그럼 그 디폴트 게이트웨이가 다시 다른 곳으로 ARP를 보내고 보내고 보내는 연쇄작용으로 알아낸다.  
    - DNS 서버는 도메인 명과 IP를 대응 데이터베이스를 갖는다. DNS 서버는 각 조직마다 한 개씩 있고, 도메인 명을 통해 다른 조직의 IP를 알고싶다면 그 조직의 DNS 서버에 물어봐야 한다.
  - **[제 2계층] 데이터링크 계층**
    - **신호가 닿는 범위(세그먼트) 내에서의 데이터 전송**
    - 이더넷에 사용되는 주소는 **MAC주소**로, 인터페이스에 지정된 고정 주소이며 유일한 주소이다.
    - 이더넷에서는 허브의 플러딩을 통해 수신된 프레임의 수신처 MAC주소를 통해 자신의 것 외에는 파기한다.
    - 허브에서 발생하는 충돌을 막기 위해 스위치를 사용하는데, 스위치는 "포트-MAC주소" 로 매핑된 어드레스 테이블을 통해 수신처 MAC주소에 해당하는 포트로만 프레임을 송신한다.
    - 동일한 수신처에 대한 송신이 중첩되면 이는 충돌이 나지 않게끔 버퍼에서 관리한다.
  - **[제 1계층] 물리 계층**
    - 1계층은 데이터가 지나는 것에 대한 순서와 규칙에 따라 **실제로** **상대에게 데이터를 전달하는** 역할
- **REST**  
  REST는 복수의 아키텍처 스타일을 조합하여 구축한 복합 아키텍처 스타일이다. 총 6가지의 아키텍쳐 스타일이 조합되었는데 다음과 같다.
  1. 유니폼 인터페이스(Uniform interface)  
  URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다. (GET, POST, PUT, DELETE 등등 8가지의 메서드만 한정 되어있는 것. 그리고 이를 통해 같은 인터페이스를 갖는 것. 호환성 이슈가 발생하지 않음.)
  2. 레이어드(Layered)  
  시스템이 계층적으로 분리되어있는 아키텍처 스타일을 말한다.
  3. 클라이언트 / 서버  
  클라이언트와 서버가 서로 통신하는 형태의 아키텍처 스타일을 말한다.
  4. 코드 온 디맨드  
  서버로부터 코드를 다운받아서 클라이언트에서 실행하는 아키텍처 스타일을 말한다.
  5. 캐시  
  서버로부터 한 번 가져온 리소스는 클라이언트에서 돌려쓰는 방식을 말한다.
  6. 스테이트리스(Stateless)  
  서버에서 클라이언트의 상태를 가지지 않는 것을 말한다.
- **CORS**  
  CORS(Cross-Origin Resource Sharing)는 서버 데이터에 부수 효과(side effect)를 일으킬 수 있는 HTTP 요청 메서드(GET을 제외한 HTTP 메서드)에 대해, 보안상의 이유로 브라우저들이 다른 도메인에게 XHR 요청을 보내는 것을 제한한 것이다.
- **함수의 선언식과 표현식의 호이스팅**  
  JavaScript에서 호이스팅은 실제로 일어나는 것은 아니고 실행 컨텍스트의 동작을 설명하는 하나의 방법으로 사용된다. 함수의 실행으로 인해 실행 컨텍스트가 만들어지면 해당 함수 내부의 변수나 함수와 같은 정보들은 실행 컨텍스트 객체에 수집된다. 따라서 코드가 한줄한줄 이어나갈 때, 이미 해당 스코프에 있는 변수나 함수와 같은 정보들을 알고있기 때문에 마치 맨 위에 선언된 것 처럼(호이스팅 된 것 처럼) 사용할 수 있게된다.  
  참고로 함수의 선언식(function get() {...})은 호이스팅이 일어나지만 표현식(const get = () => {...} 또는, const get = function () {...})은 호이스팅이 일어나지 않는다.
- **call, apply, bind의 차이**  
  기능은 모두 동일하다.

    ```js
    const func = function (name, number) {
    	console.log(`${this.hello} ${name}`, number);
    }

    const binded = func.bind({ hello: 'hi' });
    binded('woomin', 10); // 'hi woomin' 10
    func.call({ hello: 'hi' }, 'woomin',  10); // 'hi woomin' 10
    func.apply({ hello: 'hi' }, ['woomin', 10]); // 'hi woomin' 10
    ```

- **callback과 메서드**  
  callback 함수도 결국은 함수이기 때문에 디폴트로 전역 객체를 바인딩하게 된다. 따라서 메서드를 콜백으로 넣어주어도 결국은 함수로 인식되기 때문에 해당 메서드의 this를 참조할 수 없다. 그러므로 이 경우 명시적으로 this를 바인딩해주어야 한다.

    ```js
    const obj = {
      name: 'woomin',
      getName() {
        return this.name;
      }
    }

    const printName = (callback) => {
      console.log(callback());
    }

    printName(obj.getName); // '' 아무 것도 찍히지 않음.
    printName(obj.getName.bind(obj)); // 'woomin'
    printName(() => obj.getName()); // 'woomin'
    ```

- **실행 컨텍스트**  
  실행 컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이며, 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수의 실행이다.
- **호이스팅**  
  JavaScript에서 호이스팅은 실제로 일어나는 것은 아니고 실행 컨텍스트의 동작을 설명하는 하나의 방법으로 사용된다. 함수의 실행으로 인해 실행 컨텍스트가 만들어지면 해당 함수 내부의 변수나 함수와 같은 정보들은 실행 컨텍스트 객체에 수집되기 때문에 코드가 한줄한줄 이어나갈 때, 이미 해당 스코프에 있는 변수나 함수와 같은 정보들을 알고있어서 마치 맨 위에 선언된 것 처럼(호이스팅 된 것 처럼) 사용할 수 있게된다.  
  참고로 함수의 선언식(function get() {...})은 호이스팅이 일어나지만 표현식(const get = () => {...} 또는, const get = function () {...})은 호이스팅이 일어나지 않는다.  
  실행 컨텍스트는 다음과 같이 이루어져 있다.

    ```js
    ExecutionContext = {
    	LexicalEnvironment: [Lexical Environment] {
    	  environment record: {},
    	  outter enviroment reference: {}
    	},
    	VariableEnvironment: [Lexical Environment],
    	ThisBinding: [object]
    }
    ```

    여기서 LexicalEnvironment는 현재 실행 환경에 대한 변수나 참조에 대한 정보를 가지게 되는데 이는 곧 현재 Context에서 변수나 어떤 값들 (자원)을 가져올때 어디서 가져올 것이냐에 대한 답이다.
- **스코프 체인**  
  식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다. 그리고 이를 가능하게 하는 것이 LexicalEvironment의 outerEnvironmentReference이다.
- **클로저**  
  클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 B를 외부함수로 전달할 경우 A의 샐행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상이다.
- **클로저를 사용하는 이유**
  1. 콜백함수 내부에서 외부 데이터를 사용하고자 할 때
  2. 접근 권한 제어(정보를 은닉하기 위해서)
  3. 부분 적용 함수
  4. 커링

## Future Action Plans

- 오늘 정리한 내용들 노션에 깔끔하게 잘 정리해 두었는데 시간날때 반드시 다시 복습하도록 하겠습니다.

## Feedback
