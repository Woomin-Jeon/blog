---
title: 2020-08-17 TIL
date: 2020-08-17
tag: [TIL]
---

## Facts

- 아침에는 "코어 자바스크립트"를 읽었습니다.
- 부스트 캠프 챌린지에 참여하였습니다.
- 8월 1일자부터 8월 8일자 TIL까지 셀프 피드백을 하였습니다.

## Feelings

- 오늘 미션이 네트워크 관련이어서 오랜만에 네트워크 책을 펴들었는데, 잊어먹은 것도 많았고, 그만큼 기억하고 있는 것도 많았습니다. 재미있었어요.

## Findings

- **IPv4 vs IPv6**
  - IPv4 어드레스의 고갈 위험에 대처하기 위해 만들어진 것이 IPv6입니다.
  - IPv6는 128비트 체계로, 16비트씩 8 부분으로 나누어서 각 구분을 콜론으로 구분하며, 각 구분은 16 진수로 표현합니다.
  - 이는 IPv4 주소 체계가 32 비트 체계이며, 8비트씩 4부분으로 나누어 있다는 점과 2진수로 표현된다는 점에서 차이가 있습니다.
  - IPv6는 2^128개의 IP 주소를 만들어 낼 수 있는데 (거의 무한) IPv4와 호환되지 않아서 아직 많이 사용화되지는 않았습니다.
  - 그런데 IPv4의 어드레스 고갈 위험을 해결하기 위해 클레스리스 어드레싱 방식도 나오고, NAT, NAPT와 같은 방식도 사용되는데, 굳이 호환도 안되는 IPv6로 IPv4의 레거시들을 뜯어내서 바꿀 이유가 있는지 궁금합니다.
- **서브넷**
  - IP 주소는 계층형을 띱니다. 그렇기 때문에 커다란 네트워크를 몇 개의 네트워크로 작게 분할하게 됩니다. 이때, 분할된 작은 네트워크를 서브넷(Subnetwork)라고 합니다. 이때, IP 주소는 32비트로 고정되어 있어서 따로 서브넷 번호를 추가하는 것은 불가능 하기 때문에 호스트 번호의 비트를 "서브넷 번호 + 호스트 번호"로 분할합니다. 클래스풀 어드레싱 방식에서는 어디까지가 클래스 부분인지를 알 수 있지만, 어디까지가 서브넷 부분인지는 알 수가 없습니다. 이러한 문제를 해결하기 위해서 필요한 것이 서브넷마스크(Subnetmask)입니다. 서브넷마스크는 IP 주소 중에 어디까지가 서브넷 번호인지를 나타내는데, IP 주소와 같은 32비트이고 네트워크 번호와 서브넷 번호를 1로, 호스트 번호를 0으로 설정한 것입니다.
- **클래스, 오브젝트, 인스턴스**
  - 클래스는 타입의 구현 메커니즘입니다.
  - 객체는 타입의 인스턴스입니다.
  - 즉, 객체의 타입을 구현하는 메커니즘 중 하나로 클래스를 사용합니다.
- **함수와 메소드의 차이**  
  지금까지 객체 안에 정의된 함수가 메소드라고 알고 있었는데, 이게 아니라 함수를 객체의 메소드로서 호출할 경우 메서드로 동작하고 아닐 경우 함수로 동작한다고 합니다.

    ```javascript
    const func = (n) => console.log(n, this);
    func(10); // 10 window { ... }

    const obj = {
      method: func
    };
    obj.method(10); // 10 { method: f }
    ```

    즉, 호출 시 앞에 점(.)이 있으면 메소드이고, 아니면 함수입니다.

- **화살표 함수가 도입된 이유**  
  JavaScript에서 함수의 this는 default로 전역 객체 this를 참조합니다. 그렇기 때문에 아래와 같은 문제가 발생합니다.

    ```javascript
    const obj = {
      outer: function() {
        console.log(this); // { outer: f }

        const inner = function() {
          console.log(this); // window { ... }
        }
        inner();
      }
    };
    ```

    이렇게 갑자기 객체 내부에서 호출한 this가 전역 객체를 참조하게 되는 혼란이 생기는데, 이를 방지하고자 나온 것이 화살표 함수입니다. 화살표 함수는 this를 바인딩 하지 않고, 상위 스코프의 this를 그대로 활용합니다.

    ```javascript
    const obj = {
      outer: function() {
        console.log(this); // { outer: f }

        const inner = () => {
          console.log(this); // { outer: f }
        }
        inner();
      }
    };
    ```

- **콜백 함수에 대해서**  
  콜백함수는 함수입니다. 그러므로 객체 안에서 메서드로 사용하기 위해 존재했던 것들도 콜백으로 넘어오는 순간 함수가 되어 this 가 전역 객체를 가리키게 됩니다.

    ```javascript
    const obj = {
      getThis() {
        return this;
      }
    }

    console.log(obj.getThis()); // obj { ... }

    const execute = (func) => {
      console.log(func());
    }

    execute(obj.getThis); // global { ... }
    ```

## Future Action Plans

- 꾸준하도록 하겠습니다.

## Feedback
